import tkinter as tk
from tkinter import ttk, filedialog, messagebox, simpledialog
from datetime import datetime
from PIL import Image, ImageTk
from plc_controller import PLCController
import os, sys
from time import strftime
from threading import Timer
import json
# import green_line
# import red_line

# from Clock import clock
sys.path.insert(1, os.path.abspath(os.path.join(os.path.dirname(__file__), "../..")))
import clock
from TrainSocketServer import TrainSocketServer
########################################################################################################################


# Backend Data Structures (same as before)

commanded_speed = []
commanded_authority = []
switch_positions = []
light_states = []
block_occupancy = []

blocks = []
track_direction = []
railway_crossing = []
# heaters_work = []

switch_locations = []
light_location = []
railway_location = []
station_location = []

# environmental_temp: float
# failure_modes = []
# track_circuit_fail: bool
# railway_crossing_fail: bool
# power_fail: bool

# ticket_sales = []
# passengers_boarding = []
# passengers_disembarking = []
# train_occupancy = []
# active_trains = []
######
##############


def update_suggested_speed_display(speed):
    """Update the suggested speed display in the right panel"""
    try:
        if hasattr(right_panel, 'update_suggested_speed'):
            right_panel.update_suggested_speed(speed)
        else:
            # Fallback: try to find and update the label directly
            formatted_speed = f"{speed:.3f} mph"
            add_to_message_log(f"CTC Speed received (UI update pending): {formatted_speed}")
    except Exception as e:
        add_to_message_log(f"ERROR updating speed display: {e}", "ERROR")


# installing update_callback function
def update_callback(message):
    """Socket server callback function"""
    print(f"Socket message recieved: {message}")
    add_to_message_log(f"Socket: {message}")

# send_to_ui function
# target ui is test ui

#Example of Process Function:
def _process_message(self, data, connection=None, server_instance=None):
    """Process incoming messages from Test UI"""
    try:
        print(f"=== MAIN UI DEBUG ===")
        print(f"Received RAW data type: {type(data)}")
        print(f"Received RAW data: {repr(data)}")  # repr shows special characters
        print(f"Data length: {len(str(data)) if data else 0}")
        print(f"=== END DEBUG ===")
         # Parse the data if it's a string
        if isinstance(data, str):
            try:
                # Try to parse as JSON
                import json
                message_data = json.loads(data)
                print(f"Parsed JSON data: {message_data}")
                # message_data = parsed_data
            except json.JSONDecodeError as je:
                # If it's not JSON, treat it as a plain string message
                # print(f"Data is plain string, not JSON: {data}")
                print(f"Not valid JSON: {je}")
                # message_data = {'message': data}
            # Check if it's a simple string message
                if data.strip() == "CTC":
                    print("Got 'CTC' string - might be a connection test")
                    add_to_message_log("CTC connection test received")
                    return
                else:
                    # Try other parsing methods
                    print(f"Treating as plain string message: {data}")
                    message_data = {'message': data}
                    
        elif isinstance(data, dict):
            print(f"Data is already a dictionary: {data}")
            message_data = data
        else:
            print(f"Unknown data type: {type(data)}")
            return
        # else:
        #     # Data is already a dictionary
        #     message_data = data
        # extract command and value 
        # command = message_data.get('command')
        # value = message_data.get('value')
        # # self.handle_ctc_message(message_data)
        # print(f"Processing command: {command}, value: {value}")

        # Now process the message_data
        if message_data:
            command = message_data.get('command')
            value = message_data.get('value')
            
            print(f"Processing command: {command}, value: {value}")

        # Handle different commands
        if command == 'ctc_suggestion':
            # Use your existing function
            formatted_speed = handle_ctc_suggested_speed(value)
            if formatted_speed is not None:
                update_suggested_speed_display(formatted_speed)
                # # ADD THIS LINE - sync back to Test UI
                # self.sync_speed_to_test_ui(formatted_speed)
        elif command == 'update_speed_auth':
            test_data.handle_speed_auth_update(value)
            # self.handle_speed_auth_update(value)    
        elif command == 'set_block_occupancy':
            # existing handling
            pass
        elif command == 'set_switch_position':
            #existing handling
            pass
        else: 
            print(f"Unknown command: {command}")
    except Exception as e:
        print(f"Error processing message: {e}")

    # def sync_speed_to_test_ui(self, speed_value):
    #     """Sync speed changes back to Test UI"""
    #     try:
    #         if hasattr(self, 'server1') and self.server1:
    #             message = {
    #             'command': 'sync_suggested_speed',
    #             'value': str(speed_value),
    #             'ui_id': 'WC_HW_MainUI'
    #         }
    #             self.server1.send_to_ui("WC_HW_TestUI", message)
    #     except Exception as e:
    #         print(f"Error syncing speed to Test UI: {e}")

    def handle_ctc_suggested_speed(speed_data):
        """
        Handle CTC suggested speed messages and convert to float with 3 decimal places
        Expected formats:
        - String: "track HW", {"Suggested_speed", "float: new_speed"}
        - Dictionary: {'Suggested_speed': 'float: 45.5'}
        - Direct string: "float: 45.5"
        """
        try:
            suggested_speed = None
        
            # Handle different input formats
            if isinstance(speed_data, str):
                # Extract float value from string format
                if "float:" in speed_data:
                    # Find the float value in the string
                    import re
                    float_match = re.search(r'float:\s*([0-9]*\.?[0-9]+)', speed_data)
                    if float_match:
                        speed_str = float_match.group(1)
                        suggested_speed = float(speed_str)
                else:
                    # Try direct conversion if it's just a number string
                    suggested_speed = float(speed_data)
                
            elif isinstance(speed_data, dict):
                # Handle dictionary format
                if 'Suggested_speed' in speed_data:
                    speed_value = speed_data['Suggested_speed']
                    if isinstance(speed_value, str) and "float:" in speed_value:
                        speed_str = speed_value.split("float:")[1].strip()
                        suggested_speed = float(speed_str)
                    else:
                        suggested_speed = float(speed_value)
                elif 'value' in speed_data:
                    # Alternative dictionary format
                    suggested_speed = float(speed_data['value'])
        
            # Format to 3 decimal places if conversion was successful
            if suggested_speed is not None:
                formatted_speed = round(suggested_speed, 3)
                add_to_message_log(f"CTC Suggested Speed Received: {formatted_speed:.3f} mph")
                return formatted_speed
            else:
                add_to_message_log("ERROR: Could not extract speed from CTC message", "ERROR")
            
        except ValueError as e:
            add_to_message_log(f"ERROR: Invalid speed format - {e}", "ERROR")
        except Exception as e:
            add_to_message_log(f"ERROR: Processing CTC speed message - {e}", "ERROR")
    
    return None

class Clock:
    def __init__(self):
        self._fastTime = strftime("%H:%M:%S")
        self._incTimer = Timer(0.1, self._incTime)
        self._incTimer.start()

    def _incTime(self):
        self._incTimer = Timer(0.1, self._incTime)
        self._incTimer.start()

        hours = int(self._fastTime[:2])
        mins = int(self._fastTime[3:5])
        secs = int(self._fastTime[6:])

        secs += 1
        #increment fast time by 1 second every 100 ms

        if (secs == 60):
            secs = 0
            mins += 1

            if (mins == 60):
                mins = 0
                hours += 1

                if (hours == 24):
                    hours = 0

        self._fastTime = f"{hours:02d}:{mins:02d}:{secs:02d}"
    
    def getTime(self):
        return self._fastTime[:5]
    
    def endTimer(self):
        self._incTimer.cancel()


# Enhanced Mock data class for both panels
class UITestData:
    def __init__(self):
        # Define your block to section mapping
        self.block_sections = {
            "74": "M", "75": "M", "76": "M",
            "77": "N", "78": "N", "79": "N", "80": "N", "81": "N", "82": "N", "83": "N", "84": "N", "85": "N",
            "86": "O", "87": "O", "88": "O",
            "89": "P", "90": "P", "91": "P", "92": "P", "93": "P", "94": "P", "95": "P", "96": "P", "97": "P",
            "98": "Q", "99": "Q", "100": "Q",
            "101": "R",
            "102": "S", "103": "S", "104": "S",
            "105": "T", "106": "T", "107": "T", "108": "T", "109": "T",
            "110": "U", "111": "U", "112": "U", "113": "U", "114": "U", "115": "U", "116": "U",
            "117": "V", "118": "V", "119": "V", "120": "V", "121": "V",
            "122": "W", "123": "W", "124": "W", "125": "W", "126": "W", "127": "W", "128": "W", 
            "129": "W", "130": "W", "131": "W", "132": "W", "133": "W", "134": "W", "135": "W",
            "136": "W", "137": "W", "138": "W", "139": "W", "140": "W", "141": "W", "142": "W", "143": "W",
            "144": "X", "145": "X", "146": "X",
            "147": "Y", "148": "Y", "149": "Y",
            "150": "Z"
        }
        
        # Initialize ALL data attributes first
        self.track_data = {
            "crossings": {
            "Railway Crossing: 19": {"condition": "Normal", "lights": "Red", "bar": "Closed"}
            },
        "switches": {
            "Switch 12-13": {"condition": "Normal", "direction": "Section C-D(12-13)"},
            "Switch 28-29": {"condition": "Normal", "direction": "Section F-G(28-29)"},
            "Switch 57-Yard": {"condition": "Normal", "direction": "Section I-J(57-Yard)"}
            },
        "lights": {
            "Light 12": {"condition": "Normal", "signal": "Green"},
            "Light 28": {"condition": "Normal", "signal": "Yellow"},
            "Light 57": {"condition": "Normal", "signal": "Red"},
            "Light 19": {"condition": "Normal", "signal": "Red"}
            }
        }

        # Updated block_sections mapping for Green Line A-L
        self.block_sections = {
        # Section A
            "1": "A", "2": "A", "3": "A",
        # Section B
            "4": "B", "5": "B", "6": "B",
        # Section C
            "7": "C", "8": "C", "9": "C", "10": "C", "11": "C", "12": "C",
        # Section D
            "13": "D", "14": "D", "15": "D", "16": "D",
        # Section E
            "17": "E", "18": "E", "19": "E", "20": "E",
        # Section F
            "21": "F", "22": "F", "23": "F", "24": "F", "25": "F", "26": "F", "27": "F", "28": "F",
        # Section G
            "29": "G", "30": "G", "31": "G", "32": "G",
        # Section H
            "33": "H", "34": "H", "35": "H",
        # Section I
            "36": "I", "37": "I", "38": "I", "39": "I", "40": "I", "41": "I", "42": "I", "43": "I",
            "44": "I", "45": "I", "46": "I", "47": "I", "48": "I", "49": "I", "50": "I", "51": "I",
            "52": "I", "53": "I", "54": "I", "55": "I", "56": "I", "57": "I",
        # Section J
            "58": "J", "59": "J", "60": "J", "61": "J", "62": "J",
        # Section K
            "63": "K", "64": "K", "65": "K", "66": "K", "67": "K", "68": "K",
        # Section L
            "69": "L", "70": "L", "71": "L", "72": "L", "73": "L"
        }

        self.filtered_track_data = self.track_data.copy()

        # Initialize block_data (make sure this exists too)
        self.block_data = []  # Add your actual block data here
        self.filtered_block_data = self.block_data.copy()

           # Sample block data: [Occupied, Line, Block]
        load_data = self.load_complete_track_data("green_line.txt")
        if load_data and isinstance(load_data, list):
            self.block_data = load_data
            self.filtered_block_data = self.block_data.copy()
        # if self.block_data: self.filter_block_data.copy()        
        else: 
            self.block_data = []
            self.filtered_block_data = self.block_data.copy()

        # SOCKET SERVER
        self.server1 = TrainSocketServer(port=12344, ui_id="Track HW")
        self.server1.set_allowed_connections(["WC_HW_TestUI", "CTC", "Track Model"])
        self.server1.start_server(_process_message)
        
        # Connect to other UIs
        self.server1.connect_to_ui('localhost', 12346, "WC_HW_TestUI")
        self.server1.connect_to_ui('localhost', 12341, "CTC")
        self.server1.connect_to_ui('localhost', 12344, "Track Model")

        # Current line
        self.current_line = "Green"
        # Maintenance mode
        self.maintenance_mode = False
        # Callbacks
        self.on_line_change = []
        self.on_block_change = []

        self.maintenance_changes = {
            "switches": True,
            "lights": True,
            "crossing": True,
            "block_occupancy": True
        }

        # Call this after a short delay
        if hasattr(self, 'root'):
            self.root.after(2000, self.verify_server_running)

    def load_complete_track_data(self, filename="green_line.txt"):
        """Load all green line blocks, merging sections where available"""
        complete_data = []

        try:
            import os
            # Debug statments:
            # print(f"Loading track data from: {filename}")
            # print(f"File exists: {os.path.exists(filename)}")
            # print(f"block_sections defined: {hasattr(self, 'block_sections')}")

        # Simple file read
            with open(filename, 'r') as file:
                lines = file.readlines()
        
            # print(f"SUCCESS: Read {len(lines)} lines from {filename}")
            start_line = 0
            if len(lines) > 0 and "Line,Section,Block,Infrastructure" in lines[0]:
                start_line = 1  # Skip header line

            for line in lines[1:]:  # Skip header line
                    line = line.strip()
                    if line:
                        # parts = line.split(',')
                        parts = [part.strip() for part in line.split(',')]
                    
                    if len(parts) >= 5: # at least 7 columns?
                        line_name = parts[0]
                        section_name = parts[1]
                        block_number = parts[2]
                        infrastructure = parts[4] if len(parts) > 6 else ""
                        
                    block_entry = ["No", line_name, block_number, section, infrastructure]
                    complete_data.append(block_entry)
                    
                    # Get section letter from mapping (empty string if not in your list)
                    # section = self.block_sections.get(block_number, "")
                        
                        # Create block entry in your format
                        
            
            # Debug statements: printing data read from green.txt
                    #     print(f"DEBUG: Added block {block_number}: {block_entry}")
                    # else:
                    #     print(f"DEBUG: Skipping line {line_num} - not enough parts: {parts}")            
            
            # print(f"Loaded complete track data for {len(complete_data)} blocks")
            # return complete_data

        except Exception as e:
            print(f"Error loading complete track data: {e}")
            return []

    def verify_server_running(self):
        """Verify the socket server is actually running"""
        if hasattr(self, 'server1') and self.server1:
            print(f"=== SERVER VERIFICATION ===")
            print(f"Server running: {self.server1.running}")
            print(f"Server port: 12345")
            print(f"UI ID: {self.server1.ui_id}")
            print(f"Allowed connections: {self.server1.allowed_connections}")
        
        # Test if server socket is bound
        if hasattr(self.server1, 'server_socket'):
            print(f"Server socket: {self.server1.server_socket}")
            if self.server1.server_socket:
                print(f"Socket bound: {self.server1.server_socket.fileno() != -1}")
        print(f"=== END VERIFICATION ===")

    def create_clock_display(self, parent_frame):
        """Create a clock display in the UI"""
        clock_frame = tk.Frame(parent_frame, bg='#1a1a4d')
        clock_frame.pack(side=tk.TOP, fill=tk.X, pady=5)
        
        # Clock label
        self.clock_label = tk.Label(clock_frame, text="", 
                                   font=("Arial", 12, "bold"), 
                                   bg='#1a1a4d', fg='white')
        self.clock_label.pack(side=tk.RIGHT, padx=10)
        
        # Start updating the clock display
        self.update_clock_display()
    
    def update_clock_display(self):
        """Update the clock display every second"""
        try:
            current_time = self.clock.getTime()
            self.clock_label.config(text=f"Time: {current_time}")
        except Exception as e:
            print(f"Clock error: {e}")
            self.clock_label.config(text="Time: --:--")
        
        # Update every second
        self.clock_label.after(1000, self.update_clock_display)

    def on_closing(self):
        print("Closing application...")
        try:
            self.clock.endTimer()
        except:
            pass

        # Properly stop the socket server with comprehensive cleanup
        if hasattr(self, 'server1') and self.server1:
            try:
                # 1. First, notify connected clients
                if hasattr(self.server1, 'connections'):
                    disconnect_msg = {
                        'command': 'server_shutdown',
                        'message': 'Main UI is closing',
                        'timestamp': time.time()
                    }
                    for ui_id, connection in list(self.server1.connections.items()):
                        try:
                            self.server1.send_to_ui(ui_id, disconnect_msg)
                        except:
                            pass
                
                # 2. Stop accepting new connections
                self.server1.running = False
                
                # 3. Close all active connections
                if hasattr(self.server1, 'connections'):
                    for ui_id, connection in list(self.server1.connections.items()):
                        try:
                            if hasattr(connection, 'close'):
                                connection.close()
                        except Exception as e:
                            print(f"Error closing connection to {ui_id}: {e}")
                    self.server1.connections.clear()
                
                # 4. Close the server socket
                if hasattr(self.server1, 'server_socket') and self.server1.server_socket:
                    try:
                        self.server1.server_socket.close()
                        print("Server socket closed")
                    except Exception as e:
                        print(f"Error closing server socket: {e}")
                
                # 5. Stop any running threads
                if hasattr(self.server1, 'listen_thread') and self.server1.listen_thread:
                    try:
                        self.server1.listen_thread.join(timeout=2.0)
                    except Exception as e:
                        print(f"Error joining listen thread: {e}")
                
                print("Socket server shutdown complete")
                
            except Exception as e:
                print(f"Error during socket server shutdown: {e}")
        
        # 6. Finally, destroy the root window
        if hasattr(self, 'root') and self.root:
            try:
                self.root.destroy()
                print("Root window destroyed")
            except Exception as e:
                print(f"Error destroying root window: {e}")
        
        print("Application closed successfully")

    def get_block_table_data(self):
        return self.filtered_block_data

    def update_block_data(self, row_index, col_index, new_value):
        if 0 <= row_index < len(self.block_data):
            self.block_data[row_index][col_index] = new_value
            print(f"Updated block data: row {row_index} = {self.block_data[row_index]}")
            # Trigger callbacks
            for callback in self.on_block_change:
                callback(row_index, col_index, new_value)

    def filter_block_data(self, search_term):
        if not search_term or search_term.strip() == "":
            self.filtered_block_data = self.block_data.copy()
        else:
            search_term = search_term.lower()
            self.filtered_block_data = [
                row for row in self.block_data
                if any(search_term in str(cell).lower() for cell in row)
            ]
   
    def is_changeable(self, component_type):
        """Check if a component type can be edited in current mode"""
        if not self.maintenance_mode:
            return False
        return self.maintenance_changes.get(component_type, False)

    def handle_ctc_message(self, message_data):
        """Unified handler for all CTC messages"""
        try:
            command = message_data.get('command')
            value = message_data.get('value')
            
            if command == 'update_speed_auth':
                # Handle speed+authority updates from CTC schedule screen
                self._handle_speed_auth_update(value)
                
            elif command == 'ctc_suggestion':
                # Handle old format speed-only messages
                self._handle_old_ctc_suggestion(value)
                
            elif command == 'set_block_occupancy':
                # Handle block occupancy
                self._handle_block_occupancy(value)
                
            # Add other commands as needed
                
        except Exception as e:
            add_to_message_log(f"ERROR handling CTC message: {e}", "ERROR")

    def _handle_speed_auth_update(self, data):
        """Handle speed and authority updates from CTC"""
        try:
            if isinstance(data, dict):
                track = data.get('track', '').strip()
                block = data.get('block', '').strip()
                speed_str = data.get('speed', '0').strip()
                authority_str = data.get('authority', '0').strip()
                value_type = data.get('value_type', '').strip()
            
                # Only process if it's for the current line
                if track.lower() != self.current_line.lower():
                    print(f"Ignoring update for different line: {track} (we're on {self.current_line})")
                    return
            
                # Convert speed to float
                try:
                    speed = float(speed_str)
                    formatted_speed = round(speed, 3)
                except ValueError:
                    print(f"Invalid speed value: {speed_str}")
                    formatted_speed = 0.0
            
                # Convert authority to int
                try:
                    authority = int(authority_str)
                except ValueError:
                    print(f"Invalid authority value: {authority_str}")
                    authority = 0
            
                print(f"CTC Update: Block {block}, Speed: {formatted_speed}, Authority: {authority}, Type: {value_type}")
            
                # Update the display
                if value_type == 'suggested':
                    # Update suggested values in right panel
                    if hasattr(right_panel, 'update_suggested_speed'):
                        right_panel.update_suggested_speed(formatted_speed)
                    if hasattr(right_panel, 'update_suggested_authority'):
                        right_panel.update_suggested_authority(authority)
                
                    # Also log the update
                    add_to_message_log(f"CTC Suggested Values: Speed={formatted_speed:.3f} mph, Authority={authority} blocks for Block {block}")
            
                elif value_type == 'commanded':
                    # Update commanded values
                    if hasattr(right_panel, 'auth_entry'):
                        right_panel.auth_entry.delete(0, tk.END)
                        right_panel.auth_entry.insert(0, f"{authority} blocks")
                
                    if hasattr(right_panel, 'speed_entry'):
                        right_panel.speed_entry.delete(0, tk.END)
                        right_panel.speed_entry.insert(0, f"{formatted_speed:.3f} mph")
                
                    add_to_message_log(f"CTC Commanded Values: Speed={formatted_speed:.3f} mph, Authority={authority} blocks for Block {block}")
            
        except Exception as e:
            print(f"Error handling speed/auth update: {e}")
            add_to_message_log(f"ERROR processing CTC update: {e}", "ERROR")

    def _handle_old_ctc_suggestion(self, speed_data):
        """Handle old format CTC speed-only messages (backward compatibility)"""
        try:
            # This is your original handle_ctc_suggested_speed logic
            suggested_speed = None
        
            if isinstance(speed_data, str):
                if "float:" in speed_data:
                    import re
                    float_match = re.search(r'float:\s*([0-9]*\.?[0-9]+)', speed_data)
                    if float_match:
                        suggested_speed = float(float_match.group(1))
                else:
                    suggested_speed = float(speed_data)
                
            elif isinstance(speed_data, dict):
                if 'Suggested_speed' in speed_data:
                    speed_value = speed_data['Suggested_speed']
                    if isinstance(speed_value, str) and "float:" in speed_value:
                        speed_str = speed_value.split("float:")[1].strip()
                        suggested_speed = float(speed_str)
                    else:
                        suggested_speed = float(speed_value)
                elif 'value' in speed_data:
                    suggested_speed = float(speed_data['value'])
        
            if suggested_speed is not None:
                formatted_speed = round(suggested_speed, 3)
                if hasattr(right_panel, 'update_suggested_speed'):
                    right_panel.update_suggested_speed(formatted_speed)
                add_to_message_log(f"CTC Speed (old format): {formatted_speed:.3f} mph")
            
        except Exception as e:
            add_to_message_log(f"ERROR processing old CTC format: {e}", "ERROR")

# Create mock data instance
test_data = UITestData()
# Temporary safety check - ensure filtered_track_data exists
if not hasattr(test_data, 'filtered_track_data'):
    print("Warning: filtered_track_data not found, creating it now...")
    test_data.filtered_track_data = test_data.track_data.copy() if hasattr(test_data, 'track_data') else {"switches": {}, "lights": {}, "crossings": {}}
#######################################################################################################################


# Root window setup
root = tk.Tk()
root.title("Wayside Controller Hardware UI")
root.geometry("1400x900")
root.configure(bg="#0b1443")

# ========== HEADER ========== #
header_frame = tk.Frame(root, bg="#0b1443")
header_frame.pack(fill="x", pady=10)

# Load and display the BLT logo
try:
    # Debug: Check current directory and file existence
    current_dir = os.getcwd()
    print(f"Current working directory: {current_dir}")
    
    # List all files in current directory
    # print("Files in current directory:")
    # for file in os.listdir(current_dir):
    #     print(f"  - {file}")
    
    # Check if file exists
    # logo_path = "/home/siram/TRAINS-TEAM2/blt logo.png"
    logo_path = "blt logo.png"
    print(f"Looking for logo at: {logo_path}")
    print(f"Logo file exists: {os.path.exists(logo_path)}")
    
    # Load the image and resize it appropriately
    logo_image = Image.open(logo_path)
    logo_image = logo_image.resize((60, 60), Image.Resampling.LANCZOS)
    logo_photo = ImageTk.PhotoImage(logo_image)
   
    # Create label with image
    logo = tk.Label(header_frame, image=logo_photo, bg="#0b1443")
    logo.image = logo_photo  # Keep a reference to prevent garbage collection
    logo.pack(side="left", padx=15)
    print("SUCCESS: Logo loaded successfully!")
    
except Exception as e:
    # Fallback to text if image loading fails
    print(f"Error loading logo: {e}")
    logo = tk.Label(header_frame, text="ðŸš‰", bg="#0b1443", fg="white", font=("Arial", 20))
    logo.pack(side="left", padx=15)

#creating a frame to contain buttons and status of PLC
plc_upload_btn = tk.Button(header_frame, text="Select PLC File", font=("Arial", 11, "bold"),
    width=16, height=2, command=lambda: select_plc_file())
plc_upload_btn.pack(side="left", padx=20)

run_plc_btn = tk.Button(
    header_frame,
    text="Run PLC",
    font=("Arial", 11, "bold"),
    width=16,
    height=2,
    bg="#008000",
    fg="white",
    command=lambda: run_plc_file()
)
run_plc_btn.pack(side="left", padx=10)

################### Differnt Line choice ##########################
#toggle button for map choice (red vs green)
def toggle_line_map():
    """Switches between red and green line data"""
    if test_data.current_line== "Green":
        test_data.current_line = "Red"
        map_toggle_btn.config(text="Switch to Green Line", bg="#66cc66")
        add_to_message_log("Switched to Red Line data")
    else:
        test_data.current_line = "Green"
        map_toggle_btn.config(text="Switch to Red Line", bg="#ff6666")
        add_to_message_log("Switched to Green Line data")

    # Load the appropriate track data
    load_line_data(test_data.current_line)
    
    # Trigger line change callbacks to update all panels
    for callback in test_data.on_line_change:
        callback()

def load_line_data(line_name):
    """Load track data for the specified line"""
    try:
        if line_name == "Green":
            filename = "green_line.txt"
            # Update track data for green line
            test_data.track_data = {
                "crossings": {
                    "Railway Crossing: 19": {"condition": "Normal", "lights": "Red", "bar": "Closed"}
                },
                "switches": {
                    "Switch 12-13": {"condition": "Normal", "direction": "Blocks 12-13"},
                    "Switch 28-29": {"condition": "Normal", "direction": "Blocks 28-29"},
                    "Switch 57-Yard": {"condition": "Normal", "direction": "Blocks 57-Yard"}
                },
                "lights": {
                    "Light 12": {"condition": "Normal", "signal": "Green"},
                    "Light 28": {"condition": "Normal", "signal": "Yellow"},
                    "Light 57": {"condition": "Normal", "signal": "Red"},
                    "Light 19": {"condition": "Normal", "signal": "Red"}
                }
            }
            # Update block sections for Green Line A-L
            test_data.block_sections = {
                "1": "A", "2": "A", "3": "A",
                "4": "B", "5": "B", "6": "B",
                "7": "C", "8": "C", "9": "C", "10": "C", "11": "C", "12": "C",
                "13": "D", "14": "D", "15": "D", "16": "D",
                "17": "E", "18": "E", "19": "E", "20": "E",
                "21": "F", "22": "F", "23": "F", "24": "F", "25": "F", "26": "F", "27": "F", "28": "F",
                "29": "G", "30": "G", "31": "G", "32": "G",
                "33": "H", "34": "H", "35": "H",
                "36": "I", "37": "I", "38": "I", "39": "I", "40": "I", "41": "I", "42": "I", "43": "I",
                "44": "I", "45": "I", "46": "I", "47": "I", "48": "I", "49": "I", "50": "I", "51": "I",
                "52": "I", "53": "I", "54": "I", "55": "I", "56": "I", "57": "I",
                "58": "J", "59": "J", "60": "J", "61": "J", "62": "J",
                "63": "K", "64": "K", "65": "K", "66": "K", "67": "K", "68": "K",
                "69": "L", "70": "L", "71": "L", "72": "L", "73": "L"
            }
        else:  # Red line
            filename = "red_line.txt"
            # Updated track data for first half of Red Line (A-G sections)
            test_data.track_data = {
                "crossings": {
                    "Railway Crossing: 19": {"condition": "Normal", "lights": "Red", "bar": "Closed"}
                },
                "switches": {
                    "Switch 12-13": {"condition": "Normal", "direction": "Blocks 12-13 (C-D)"},
                    "Switch 1-13": {"condition": "Normal", "direction": "Blocks 1-13 (D-A)"},
                    "Switch 28-29": {"condition": "Normal", "direction": "Blocks 28-29(F-G)"},
                    "Switch 150-28": {"condition": "Normal", "direction": "Blocks 150-28(F-Z)"}
                },
                "lights": {
                    "Light 9": {"condition": "Normal", "signal": "Green"},
                    "Light 15": {"condition": "Normal", "signal": "Yellow"},
                    "Light 11": {"condition": "Normal", "signal": "Red"}
                }
            }
            # Update block sections for Red Line A-G
            test_data.block_sections = {
                # Section A
                "1": "A", "2": "A", "3": "A",
                # Section B
                "4": "B", "5": "B", "6": "B",
                # Section C
                "7": "C", "8": "C", "9": "C",
                # Section D
                "10": "D", "11": "D", "12": "D",
                # Section E
                "13": "E", "14": "E", "15": "E",
                # Section F
                "16": "F", "17": "F", "18": "F", "19": "F", "20": "F",
                # Section G
                "21": "G", "22": "G", "23": "G"
            }
        
        # Load block data
        test_data.block_data = test_data.load_complete_track_data(filename)
        test_data.filtered_block_data = test_data.block_data.copy()
        test_data.filtered_track_data = test_data.track_data.copy()
        
        add_to_message_log(f"Loaded {line_name} Line data from {filename}")
        
    except Exception as e:
        add_to_message_log(f"ERROR loading {line_name} Line data: {e}", "ERROR")

map_toggle_btn = tk.Button(
    header_frame,
    text="Switch to Red Line",
    font=("Arial", 11, "bold"),
    width=18,
    height=2,
    bg="#ff6666",  # Currently in
    fg="white",
    command=toggle_line_map
)
map_toggle_btn.pack(side="left", padx=10)
###################################################################################################


# creating a center frame for additonal buttons
center_frame = tk.Frame(header_frame, bg="#0b1443")
center_frame.pack(side="left", expand=True)

# Clock - positioned between PLC buttons and LEDs
clock_frame = tk.Frame(header_frame, bg="#0b1443")
clock_frame.pack(side="right", padx=15)
clock_label = tk.Label(
    header_frame, 
    text=clock.clock.getTime(), 
    font=("Arial", 12, "bold"), 
    bg="white") 
    # fg="white")
clock_label.pack(side="right", anchor="ne")

# Fault LED indicator
fault_led = tk.Label(header_frame, text="Fault LED", bg="gray", fg="white", width=10, font=("Arial", 10, "bold"))
fault_led.pack(side="right", padx=30)

# Maintenance Mode LED indicator:
maint_led = tk.Label(header_frame, text="MM OFF", bg="gray", fg="white", width=10, font=("Arial", 10, "bold"))
maint_led.pack(side="right", padx=10)

#PLC Upload LED indicator:
plc_LED = tk.Label(header_frame, text="PLC Ready", bg="gray", fg="black", font=("Arial", 10, "bold"))
plc_LED.pack(side="left", padx=0)

# PLC upload and run buttons
def trigger_plc_fault():
    """Simulate a railroad crossing fault (PLC triggered)."""
    plc_instance.set_crossing_fault(True)
    fault_led.config(bg="red", text="FAULT")  # Turn LED red

def clear_plc_fault():
    """Clear the railroad crossing fault."""
    plc_instance.set_crossing_fault(False)
    fault_led.config(bg="green", text="OK")  # Turn LED green

selected_plc_file = None
plc_instance = None

def update_clock_display():
    """Continuously update the clock display every second"""
    # try:
    #     current_time = clock_instance.getTime()
    #     clock_label.config(text=current_time)
    # except Exception as e:
    #     print(f"Clock error: {e}")
    #     clock_label.config(text="--:--")
    time = clock.clock.getTime()
    self.clockText.configure(text = time)
    self.clockTimer = self.root.after(100, self.updateTime)

# update_clock_display()

#######################################################################################
#######################################################################################
# ========== BODY ========== #
body_frame = tk.Frame(root, bg="#0b1443")
body_frame.pack(fill="both", expand=True, padx=15, pady=10)

# Two main pages (stacked)
main_frame = tk.Frame(body_frame, bg="#0b1443")
maintenance_frame = tk.Frame(body_frame, bg="#0b1443")

for frame in (main_frame, maintenance_frame):
    frame.place(relwidth=1, relheight=1)

#######################################################################################
#######################################################################################
# ---------- CENTER AREA (Map + Message Log) ---------- #
center_container = tk.Frame(main_frame, bg="#0b1443")
center_container.pack(side="left", fill="both", expand=True, padx=5, pady=5)

# Map Display
map_frame = tk.Frame(center_container, bg="white", relief="ridge", borderwidth=3, width=750, height=650)
map_frame.pack(fill="none", expand=False)  # Don't expand, use fixed size
map_frame.pack_propagate(False)  # Prevent frame from shrinking to fit contents
##
# Create canvas for displaying the track image
canvas = tk.Canvas(map_frame, bg="white")
canvas.pack(fill="both", expand=True)
###########################################################################################################
##########################################################################################################
# Load and display the Red Green Blue Line track image
# try:
#     track_image = Image.open("./home/siram/TRAINS-TEAM2/Red and Green Line.png")
#     # Resize image to fit the canvas while maintaining aspect ratio
#     track_image = track_image.resize((700, 400), Image.Resampling.LANCZOS)
#     track_photo = ImageTk.PhotoImage(track_image)
   
#     # Display image on canvas
#     canvas.create_image(360, 215, image=track_photo)
#     canvas.image = track_photo  # Keep a reference to prevent garbage collection
   
# except Exception as e:
#     # Fallback if image loading fails
#     print(f"Error loading track image: {e}")
#     canvas.create_text(400, 250, text="TRACK MAP DISPLAY\n(Red and Green Line.png not found)",
#                       fill="black", font=("Arial", 14, "bold"), justify="center")

# Load and display the Green Line track image
try:
    # Debug: Check current directory and file existence
    current_dir = os.getcwd()
    print(f"Current working directory: {current_dir}")
    
    # List all files in current directory
    # print("Files in current directory:")
    # for file in os.listdir(current_dir):
    #     print(f"  - {file}")
    
    # Check if file exists in TRAINS-TEAM2 folder
    image_path = "Red and Green Line.png"
    print(f"Looking for image at: {image_path}")
    print(f"File exists: {os.path.exists(image_path)}")
    
    track_image = Image.open(image_path)
    # Resize image to fit the canvas while maintaining aspect ratio
    track_image = track_image.resize((700, 600), Image.Resampling.LANCZOS)
    track_photo = ImageTk.PhotoImage(track_image)
   
    # Display image on canvas
    canvas.create_image(375, 300, image=track_photo)
    canvas.image = track_photo  # Keep a reference to prevent garbage collection
    print("SUCCESS: Image loaded successfully!")
   
except Exception as e:
    # Fallback if image loading fails
    print(f"Error loading track image: {e}")
    canvas.create_text(400, 250, text="TRACK MAP DISPLAY\n(Red and Green Line.png not found)",
                      fill="black", font=("Arial", 14, "bold"), justify="center")
#######################################################################################################
#######################################################################################################

# Add the MessageLogger class definition right after your imports
class MessageLogger:
    def __init__(self, text_widget):
        self.text_widget = text_widget
       
    def log(self, message, level="INFO"):
        """Add timestamped message with color coding"""
        self.text_widget.config(state="normal")
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        color = self.get_color_for_level(level)
        self.text_widget.insert("end", f"{timestamp} [{level}] {message}\n")
        self.text_widget.tag_config(level, foreground=color)
        self.text_widget.see("end")
        self.text_widget.config(state="disabled")
   
    def get_color_for_level(self, level):
        colors = {"INFO": "white", "WARNING": "yellow", "ERROR": "red", "DEBUG": "cyan"}
        return colors.get(level, "white")
   
    def clear(self):
        self.text_widget.config(state="normal")
        self.text_widget.delete(1.0, "end")
        self.text_widget.config(state="disabled")

# Message Log (now underneath the map)
message_frame = tk.Frame(center_container, bg="#0b1443", height=150)
message_frame.pack(fill="x", pady=(10, 0))

tk.Label(message_frame, text="Messages", bg="#0b1443", fg="white", font=("Arial", 12, "bold")).pack(anchor="w", padx=5)

# Create a frame for the text widget with scrollbar
log_container = tk.Frame(message_frame, bg="#0b1443")
log_container.pack(fill="x", pady=5)

log_text = tk.Text(log_container, height=6, bg="#111b52", fg="white", font=("Courier", 10))
scrollbar = tk.Scrollbar(log_container, orient="vertical", command=log_text.yview)
log_text.configure(yscrollcommand=scrollbar.set)

log_text.pack(side="left", fill="x", expand=True)
scrollbar.pack(side="right", fill="y")

# Create MessageLogger instance
message_logger = MessageLogger(log_text)

# Keep this function for backward compatibility with existing code
def add_to_message_log(message):
    """Wrapper for backward compatibility"""
    message_logger.log(message, "INFO")

# plc = PLCController(add_to_message_log)
# plc_instance = PLCController(add_to_message_log)
# plc_instance.main()  # Runs PLC logic
#
# Initialize with some messages
add_to_message_log("INFO: UI initialized.")
add_to_message_log("INFO: Map display loaded.")
add_to_message_log("INFO: Control panels ready.")
###########################################################################################
############################      PLC MANAGER  ############################################

# Add PLCManager class definition after MessageLogger
class PLCManager:
    def __init__(self, message_logger):
        self.message_logger = message_logger
        self.plc_instance = None
        self.current_file = None
       
    def load_plc_file(self, file_path):
        try:
            import importlib.util
            spec = importlib.util.spec_from_file_location("plc_module", file_path)
            plc_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(plc_module)
           
            self.plc_instance = plc_module.PLCController(self.message_logger.log)
            self.current_file = file_path
            self.message_logger.log(f"PLC file loaded: {file_path}", "INFO")
            return True
        except Exception as e:
            self.message_logger.log(f"PLC load error: {e}", "ERROR")
            return False
   
    def run_plc(self):
        if not self.plc_instance:
            self.message_logger.log("No PLC file loaded", "WARNING")
            messagebox.showwarning("No PLC File", "Please upload a PLC file first!")
            return False
       
        try:
            self.plc_instance.main()
            self.message_logger.log(f"PLC file executed: {self.current_file.split('/')[-1]}", "INFO")
            return True
        except Exception as e:
            self.message_logger.log(f"PLC runtime error: {e}", "ERROR")
            return False
   
    def get_status(self):
        return {
            "loaded": self.plc_instance is not None,
            "file": self.current_file
        }
   
#creating mock data instance
test_data = UITestData()  

# Creating MessageLogger
message_logger = MessageLogger(log_text)

# Create PLCManager instance (after message_logger is created)
plc_manager = PLCManager(message_logger)

# Update the button functions:
def select_plc_file():
    """Open a file dialog to select a PLC file"""
    file_path = filedialog.askopenfilename(
        title ="Select PLC File",
        filetypes=[("Python Files", "*.py")]
    )
    if file_path:
        if plc_manager.load_plc_file(file_path):
            # Update LED or other UI elements if needed
            plc_LED.config(bg="white", text="PLC LOADED")

def run_plc_file():
    """Run the PLC logic using the selected file."""
    if plc_manager.run_plc():
        plc_LED.config(bg="green", text="PLC RUNNING")
    else:
        plc_LED.config(bg="red", text="FAULT")

# Keep global plc_instance for backward compatibility
plc_instance = None  # This will be set by PLCManager internally

# Update buttons
plc_upload_btn.config(command=select_plc_file)
run_plc_btn.config(command=run_plc_file)

#########################################################################################
#########################################################################################

# Screen toggle checkboxes
toggle_frame = tk.Frame(header_frame, bg="#0b1443")
toggle_frame.pack(side="right", padx=30)

view_var_main = tk.BooleanVar(value=True)
view_var_maint = tk.BooleanVar(value=False)

def update_screen_view():
    if view_var_main.get():
        main_frame.tkraise()
        # When switching to main screen, update maintenance mode based on maint_check
        test_data.maintenance_mode = view_var_maint.get()
        if hasattr(right_panel, 'update_mode_ui'):
            right_panel.update_mode_ui()
    elif view_var_maint.get():
        maintenance_frame.tkraise()

main_check = tk.Checkbutton(toggle_frame, text="Main Screen", variable=view_var_main,
                            command=lambda: [view_var_maint.set(False), update_screen_view()],
                            bg="#0b1443", fg="white", selectcolor="#333", font=("Arial", 10))
main_check.grid(row=0, column=0, padx=10)

def toggle_maintenance_mode():
    """Toggle maintenance mode when Maintenance checkbox is clicked"""
    test_data.maintenance_mode = view_var_maint.get()

    # Update the maintenance LED color/text
    if test_data.maintenance_mode:
        maint_led.config(bg="orange", text="MM ON")
    else:
        maint_led.config(bg="gray", text="MM OFF")

    # Update the right panel UI
    if hasattr(right_panel, 'update_mode_ui'):
        right_panel.update_mode_ui()

    # Keep the main screen visible regardless of maintenance mode
    if view_var_main.get():
        main_frame.tkraise()


maint_check = tk.Checkbutton(toggle_frame, text="Maintenance", variable=view_var_maint,
                             command=lambda: [view_var_main.set(True), toggle_maintenance_mode(), update_screen_view()],
                             bg="#0b1443", fg="white", selectcolor="#333", font=("Arial", 10))
maint_check.grid(row=0, column=1, padx=10)


#######################################################################################
#######################################################################################
# ---------- LEFT PANEL ---------- #
class LeftPanel(tk.Frame):
    def __init__(self, parent, data):
        self.parent = parent
        super().__init__(parent, bg='#1a1a4d', width=250)
        self.pack_propagate(False)
        self.data = data
        self.create_widgets()
        self.ensure_data_initialized()
        # Connect line change callback:
        self.data.on_line_change.append(self.on_line_changed)
   
    def create_widgets(self):
        #Tabs are now controlled by header
       
        # Railway Crossing Detail
        self.create_crossing_section()
       
        # Switch Details
        self.create_switch_section()
       
        # Light Detail
        self.create_light_section()

        # Initialize with current line data
        self.update_crossing_options()

    def create_crossing_section(self):
        crossing_frame = tk.LabelFrame(self, text="Railway Crossing Detail",
                                      bg='#cccccc', font=('Arial', 9, 'bold'))
        crossing_frame.pack(fill=tk.X, pady=5)
       
        tk.Label(crossing_frame, text="Select Crossing:", bg='#cccccc').pack(pady=2)
        self.crossing_selector = ttk.Combobox(crossing_frame, width=18, state='readonly')
        self.crossing_selector.pack(pady=2)
        self.crossing_selector.bind('<<ComboboxSelected>>', self.update_crossing_display)
       
        tk.Label(crossing_frame, text="Condition:", bg='#cccccc').pack()
        self.crossing_condition = tk.Entry(crossing_frame, width=20, state='readonly')
        self.crossing_condition.pack()
       
        tk.Label(crossing_frame, text="Lights:", bg='#cccccc').pack()
        self.crossing_lights = ttk.Combobox(crossing_frame, width=18,
                                           values=["On", "Off"], state='readonly')
        self.crossing_lights.pack()
        self.crossing_lights.bind('<<ComboboxSelected>>', self.update_crossing_lights)
       
        tk.Label(crossing_frame, text="Bar:", bg='#cccccc').pack()
        self.crossing_bar = ttk.Combobox(crossing_frame, width=18, values=["Closed", "Open"], state='readonly')
        self.crossing_bar.pack()

    def update_crossing_options(self):
        """Update combobox options based on current line"""
        crossings = list(self.data.filtered_track_data.get("crossings", {}).keys())
        self.crossing_selector['values'] = crossings
        if crossings:
            self.crossing_selector.set(crossings[0])
            self.update_crossing_display()
   
    def create_switch_section(self):
        switch_frame = tk.LabelFrame(self, text="Switch Details",
                                    bg='#cccccc', font=('Arial', 9, 'bold'))
        switch_frame.pack(fill=tk.X, pady=5)
       
        tk.Label(switch_frame, text="Select Switch:", bg='#cccccc').pack(pady=2)
        self.switch_selector = ttk.Combobox(switch_frame, width=18, state='readonly')
        self.switch_selector.pack(pady=2)
        self.switch_selector.bind('<<ComboboxSelected>>', self.update_switch_display)
       
        tk.Label(switch_frame, text="Condition:", bg='#cccccc').pack()
        self.switch_condition = tk.Entry(switch_frame, width=20, state='readonly')
        self.switch_condition.pack()
       
        tk.Label(switch_frame, text="Direction:", bg='#cccccc').pack()
        self.switch_direction = ttk.Combobox(switch_frame, width=18,
                                            values=["Blocks 5-11", "Blocks 5-15"])
                                            # state='readonly') # this makes the dropdown BLANK - FIX THIS
        self.switch_direction.pack()
        self.switch_direction.bind('<<ComboboxSelected>>', self.update_switch_direction)

        # Initialize with current line data
        self.update_switch_options()

    def ensure_data_initialized(self):
        """Ensure all required data structures exist"""
        if not hasattr(self.data, 'filtered_track_data'):
            self.data.filtered_track_data = {
                "crossings": {},
                "switches": {},
                "lights": {},
                "occupancy": {}
            }
        if not hasattr(self.data, 'track_data'):
            self.data.track_data = self.data.filtered_track_data.copy()

    def update_switch_options(self):
        """Update combobox options based on current line"""
        switches = list(self.data.filtered_track_data.get("switches", {}).keys())
        self.switch_selector['values'] = switches
        if switches:
            self.switch_selector.set(switches[0])
            self.update_switch_display()
   
    def create_light_section(self):
        light_frame = tk.LabelFrame(self, text="Light Detail",
                                   bg='#cccccc', font=('Arial', 9, 'bold'))
        light_frame.pack(fill=tk.X, pady=5)
       
        tk.Label(light_frame, text="Select Light:", bg='#cccccc').pack(pady=2)
        self.light_selector = ttk.Combobox(light_frame, width=18, state='readonly')
        self.light_selector.pack(pady=2)
        self.light_selector.bind('<<ComboboxSelected>>', self.update_light_display)
       
        tk.Label(light_frame, text="Condition:", bg='#cccccc').pack()
        self.light_condition = tk.Entry(light_frame, width=20, state='readonly')
        self.light_condition.pack()
       
        tk.Label(light_frame, text="Signal:", bg='#cccccc').pack()
        self.light_signal = ttk.Combobox(light_frame, width=18,
                                        values=["Red", "Yellow", "Green", "Super Green" ],
                                        state='readonly')
        self.light_signal.pack()
        self.light_signal.bind('<<ComboboxSelected>>', self.update_light_signal)

        # Initialize with current line data
        self.update_light_options()
   
    def update_light_options(self):
        """Update combobox options based on current line"""
        lights = list(self.data.filtered_track_data.get("lights", {}).keys())
        self.light_selector['values'] = lights
        if lights:
            self.light_selector.set(lights[0])
            self.update_light_display()
           
    def on_line_changed(self):
        """Update all left panel components when line changes"""
        print(f"Left panel: Line changed to {self.data.current_line}")  # Debug
        self.update_crossing_options()
        self.update_switch_options()
        self.update_light_options()
   
    def update_crossing_display(self, event=None):
        selected = self.crossing_selector.get()
        crossings = self.data.filtered_track_data.get("crossings", {})
        if selected in crossings:
            data = crossings[selected]
            self.crossing_condition.config(state='normal')
            self.crossing_condition.delete(0, tk.END)
            self.crossing_condition.insert(0, data["condition"])
            self.crossing_condition.config(state='readonly')
            self.crossing_lights.set(data["lights"])
            self.crossing_bar.set(data["bar"])
   
    def update_crossing_lights(self, event=None):
        selected = self.crossing_selector.get()
        if selected in self.data.track_data["crossings"]:
            old_value = self.data.track_data["crossings"][selected]["lights"]
            new_value = self.crossing_lights.get()
            self.data.track_data["crossings"][selected]["lights"] = self.crossing_lights.get()
            message_logger.log(f"Crossing {selected}: Lights changed from {old_value} to {new_value}", "INFO")

    def update_switch_display(self, event=None):
        selected = self.switch_selector.get()
        switches = self.data.filtered_track_data.get("switches", {})
        if selected in switches:
            data = switches[selected]
            self.switch_condition.config(state='normal')
            self.switch_condition.delete(0, tk.END)
            self.switch_condition.insert(0, data["condition"])
            self.switch_condition.config(state='readonly')
            self.switch_direction.set(data["direction"])
   
    def update_switch_direction(self, event=None):
        selected = self.switch_selector.get()
        if selected in self.data.track_data["switches"]:
            old_value = self.data.track_data["switches"][selected]["direction"]
            new_value = self.switch_direction.get()
            self.data.track_data["switches"][selected]["direction"] = new_value
            message_logger.log(f"Switch {selected}: Direction changed from {old_value} to {new_value}")
   
    def update_light_display(self, event=None):
        selected = self.light_selector.get()
        lights = self.data.filtered_track_data.get("lights", {})
        if selected in lights:
            data = lights[selected]
            self.light_condition.config(state='normal')
            self.light_condition.delete(0, tk.END)
            self.light_condition.insert(0, data["condition"])
            self.light_condition.config(state='readonly')
            self.light_signal.set(data["signal"])
   
    def update_light_signal(self, event=None):
        selected = self.light_selector.get()
        if selected in self.data.track_data["lights"]:
            old_value = self.data.track_data["lights"][selected]["signal"]
            new_value = self.light_signal.get()
            self.data.track_data["lights"][selected]["signal"] = new_value
            message_logger.log(f"Light {selected}: Signal changed from {old_value} to {new_value}")
   
    def update_mode_ui(self):
        # Refresh UI based on maintenance mode
        # pass
        """Update UI elements based on maintenance mode"""
        # enable/diable comoboxes based on mainteneance mode and specific edits
        switch_changes = self.data.is_changeable("switches")
        light_changes = self.data.is_changeable("lights")
        crossing_changes = self.data.is_changeable("crossing")

        # update switch controls
        if switch_changes:
            self.switch_direction.config(state='readonly')
            add_to_message_log("switch controls enabled for maintenance")
        else:
            self.switch_direction.config(state='disabled')
       
        #update light controls
        self.light_signal.config(state='disabled')

        # Update crossing controls (always disabled in this design)
        self.crossing_lights.config(state='disabled')
        self.crossing_bar.config(state='disabled')

        # Visual feedback - change background colors to show editable state
        self.update_visual_feedback()

    def update_visual_feedback(self):
        """Change background colors to indicate editable fields"""
        switch_editable = self.data.is_changeable("switches")
       
        if switch_editable:
            # Make editable fields stand out
            self.switch_direction.config(background='#ffffcc')  # Light yellow for editable
        else:
            self.switch_direction.config(background='white')    # Normal white for read-only
           
        # Keep non-editable fields with normal background
        self.light_signal.config(background='#f0f0f0')          # Grayed out
        self.crossing_lights.config(background='#f0f0f0')
        self.crossing_bar.config(background='#f0f0f0')
   
    def update_switch_direction(self, event=None):
        """Only allow switch direction changes if editable"""
        if not self.data.is_changeable("switches"):
            add_to_message_log("WARNING: Switch changes not allowed in current mode", "WARNING")
            return
           
        selected = self.switch_selector.get()
        if selected in self.data.track_data["switches"]:
            old_value = self.data.track_data["switches"][selected]["direction"]
            new_value = self.switch_direction.get()
            self.data.track_data["switches"][selected]["direction"] = new_value
            add_to_message_log(f"Switch {selected}: Direction changed from {old_value} to {new_value}")
   
    def update_crossing_lights(self, event=None):
        """Prevent crossing light changes"""
        if self.data.maintenance_mode:
            add_to_message_log("WARNING: Crossing light changes not permitted in maintenance mode", "WARNING")
            # Revert to original value
            self.update_crossing_display()
   
    def update_light_signal(self, event=None):
        """Prevent light signal changes"""
        if self.data.maintenance_mode:
            add_to_message_log("WARNING: Light signal changes not permitted in maintenance mode", "WARNING")
            # Revert to original value
            self.update_light_display()

test_data = UITestData()
# Create the left panel with mock data
left_panel = LeftPanel(main_frame, test_data)
left_panel.pack(side="left", fill="y", padx=5, pady=5)

#######################################################################################
#######################################################################################

# ---------- RIGHT PANEL ---------- #
class RightPanel(tk.Frame):
    # Check how you're creating the RightPanel
# Ensure test_data contains the full block_data with all columns
    print(f"DEBUG: Block data length: {len(test_data.block_data)}")
    print(f"DEBUG: First row: {test_data.block_data[0] if test_data.block_data else 'Empty'}")
    print(f"DEBUG: Row structure: {[len(row) for row in test_data.block_data[:5]] if test_data.block_data else 'No data'}")

    def __init__(self, parent, data):
        super().__init__(parent, bg='#1a1a4d', width=250)
        self.pack_propagate(False)
        self.data = data
        
        # Store information about currently selected block
        self.current_block_info = {}
        
        # Dictionaries for commanded values by line and block
        self.commanded_authority = {"Blue": {}, "Green": {}, "Red": {}}
        self.commanded_speed = {"Blue": {}, "Green": {}, "Red": {}}
        
        # Dictionaries for suggested values by line and block
        self.suggested_authority = {"Blue": {}, "Green": {}, "Red": {}}
        self.suggested_speed = {"Blue": {}, "Green": {}, "Red": {}}

        # Connect line change callback
        self.data.on_line_change.append(self.on_line_changed)
        self.data.on_block_change.append(self.on_block_data_changed)

        # Clear any search filters and show all data
        if hasattr(self.data, 'filtered_block_data'):
            self.data.filtered_block_data = self.data.block_data.copy()
        
        # Create all UI components
        self.create_widgets()
        
        # Initialize with current data
        self.update_block_options()
        
        # Set initial yard to station commands
        self.set_yard_to_station_commands()
        
    def on_block_data_changed(self, row_index, col_index, new_value):
        """Update UI when block data changes"""
        # Update current block display if the changed block is selected
        selected_block = self.block_combo.get()
        if selected_block:
            block_num = self.data.block_data[row_index][2]
            if str(block_num) == str(selected_block):
                self.update_current_block_info()
        
        # Update the table in maintenance mode
        if self.data.maintenance_mode:
            self.create_block_table()
        
        add_to_message_log(f"[Main UI] Block {self.data.block_data[row_index][2]} updated to {new_value}")
   
    def create_widgets(self):
        """Create all UI components"""
        # Block selector
        block_frame = tk.Frame(self, bg='#cccccc')
        block_frame.pack(fill=tk.X, pady=5)
        tk.Label(block_frame, text="Block", bg='#cccccc').pack(side=tk.LEFT, padx=5)
       
        # Update block combo based on current line
        self.block_combo = ttk.Combobox(block_frame, width=15, state='readonly')
        self.block_combo.pack(side=tk.LEFT, padx=5)
        self.block_combo.bind('<<ComboboxSelected>>', self.on_block_selected)
        
        # Current block section
        self.create_current_block_section()
        
        # Suggested section
        self.create_suggested_section()
       
        # Commanded section (YOUR ORIGINAL DESIGN)
        self.create_commanded_section()
       
        # Search and block table
        self.create_block_table_section()

    def update_block_options(self):
        """Update block selector based on current line"""
        # Filter blocks for current line and sort numerically
        blocks = sorted([str(row[2]) for row in self.data.block_data 
                        if row[1] == self.data.current_line], key=int)
        self.block_combo['values'] = blocks
        if blocks:
            # Preserve selection if possible
            current_selection = self.block_combo.get()
            if current_selection in blocks:
                self.block_combo.set(current_selection)
            else:
                self.block_combo.set(blocks[0])
            self.update_current_block_info()

    def on_block_selected(self, event):
        """When a block is selected from dropdown"""
        self.update_current_block_info()
        self.update_suggested_display()
        self.update_commanded_display()

    def create_current_block_section(self):
        """Display current selected block information"""
        self.current_block_frame = tk.LabelFrame(self, text="Current Block:", 
                                               bg='#cccccc', font=('Arial', 10, 'bold'))
        self.current_block_frame.pack(fill=tk.X, pady=5)
        
        # Block number display
        tk.Label(self.current_block_frame, text="Block #:", bg='#cccccc', 
                width=10).pack(side=tk.LEFT, padx=5, pady=2)
        self.block_num_label = tk.Label(self.current_block_frame, text="", bg='white', 
                                       width=8, relief=tk.SUNKEN, anchor='w')
        self.block_num_label.pack(side=tk.LEFT, padx=2, pady=2)
        
        # Occupied status display
        tk.Label(self.current_block_frame, text="Occupied:", bg='#cccccc',
                width=10).pack(side=tk.LEFT, padx=5, pady=2)
        self.occupied_label = tk.Label(self.current_block_frame, text="", bg='white',
                                      width=8, relief=tk.SUNKEN, anchor='w')
        self.occupied_label.pack(side=tk.LEFT, padx=2, pady=2)

    def update_current_block_info(self):
        """Update current block display from data"""
        selected_block = self.block_combo.get()
        if selected_block:
            # Find block data
            for row in self.data.block_data:
                if row[1] == self.data.current_line and str(row[2]) == str(selected_block):
                    self.current_block_info = {
                        'block': row[2],
                        'line': row[1],
                        'occupied': row[0],
                        'section': row[3],
                        'infrastructure': row[4]
                    }
                    
                    # Update display
                    self.block_num_label.config(text=row[2])
                    
                    # Color coding for occupancy
                    occupied_text = row[0]
                    occupied_color = '#ffcccc' if occupied_text == "Yes" else '#ccffcc'
                    self.occupied_label.config(text=occupied_text, bg=occupied_color)
                    break

    def create_suggested_section(self):
        """Display suggested authority and speed"""
        suggested_frame = tk.LabelFrame(self, text="Suggested:",
                                       bg='#cccccc', font=('Arial', 10, 'bold'))
        suggested_frame.pack(fill=tk.X, pady=5)
        
        # Authority display
        auth_frame = tk.Frame(suggested_frame, bg='#cccccc')
        auth_frame.pack(fill=tk.X, padx=5, pady=2)
        tk.Label(auth_frame, text="Authority:", bg='#cccccc').pack(side=tk.LEFT)
        self.suggested_auth_label = tk.Label(auth_frame, text="0 blocks", bg='white',
                                           relief=tk.SUNKEN, width=12, anchor='w')
        self.suggested_auth_label.pack(side=tk.LEFT, padx=2)
        
        # Speed display
        speed_frame = tk.Frame(suggested_frame, bg='#cccccc')
        speed_frame.pack(fill=tk.X, padx=5, pady=2)
        tk.Label(speed_frame, text="Speed:", bg='#cccccc').pack(side=tk.LEFT)
        self.suggested_speed_label = tk.Label(speed_frame, text="0 mph", bg='white',
                                            relief=tk.SUNKEN, width=12, anchor='w')
        self.suggested_speed_label.pack(side=tk.LEFT, padx=2)
   
    def update_suggested_display(self):
        """Update suggested values display"""
        selected_block = self.block_combo.get()
        current_line = self.data.current_line
        
        if selected_block and current_line:
            # Check local storage first
            local_auth = self.suggested_authority.get(current_line, {}).get(selected_block)
            local_speed = self.suggested_speed.get(current_line, {}).get(selected_block)
            
            if local_auth is not None:
                self.suggested_auth_label.config(text=f"{local_auth} blocks")
                self.suggested_speed_label.config(text=f"{local_speed} mph")
            else:
                # No values found - show defaults
                self.suggested_auth_label.config(text="0 blocks")
                self.suggested_speed_label.config(text="0 mph")
        else:
            # No block selected
            self.suggested_auth_label.config(text="N/A")
            self.suggested_speed_label.config(text="N/A")
   
    def create_commanded_section(self):
        """Create commanded values input section - YOUR ORIGINAL DESIGN"""
        commanded_frame = tk.LabelFrame(self, text="Commanded:",
                                   bg='#cccccc', font=('Arial', 10, 'bold'))
        commanded_frame.pack(fill=tk.X, pady=5)
   
        # Authority section - YOUR ORIGINAL DESIGN
        auth_frame = tk.Frame(commanded_frame, bg='#cccccc')
        auth_frame.pack(fill=tk.X, padx=5, pady=2)
        tk.Label(auth_frame, text="Authority:", bg='#cccccc').pack(side=tk.LEFT)
   
        self.auth_entry = tk.Entry(auth_frame, width=10)
        self.auth_entry.insert(0, "2 blocks")  # Default value
        self.auth_entry.pack(side=tk.LEFT, padx=2)
   
        auth_button = tk.Button(auth_frame, text="Send", width=5, command=self.update_authority)
        auth_button.pack(side=tk.LEFT)
   
        # Speed section - YOUR ORIGINAL DESIGN
        speed_frame = tk.Frame(commanded_frame, bg='#cccccc')
        speed_frame.pack(fill=tk.X, padx=5, pady=2)
        tk.Label(speed_frame, text="Speed:", bg='#cccccc').pack(side=tk.LEFT)
   
        self.speed_entry = tk.Entry(speed_frame, width=10)
        self.speed_entry.insert(0, "38 mph")  # Default value
        self.speed_entry.pack(side=tk.LEFT, padx=2)
   
        speed_button = tk.Button(speed_frame, text="Send", width=5, command=self.update_speed)
        speed_button.pack(side=tk.LEFT)

    def update_authority(self):
        """Update commanded authority and log the change"""
        new_authority = self.auth_entry.get()
        block = self.block_combo.get()
        current_line = self.data.current_line
        
        if block and current_line:
            # Store in local storage
            self.commanded_authority[current_line][block] = new_authority
            # Store in shared data if available
            if hasattr(self.data, 'commanded_authority'):
                self.data.commanded_authority[current_line][block] = new_authority
        
        add_to_message_log(f"Commanded Authority updated to: {new_authority}")
        self.update_commanded_display()

    def update_speed(self):
        """Update commanded speed and log the change"""
        new_speed = self.speed_entry.get()
        block = self.block_combo.get()
        current_line = self.data.current_line
        
        if block and current_line:
            # Store in local storage
            self.commanded_speed[current_line][block] = new_speed
            # Store in shared data if available
            if hasattr(self.data, 'commanded_speed'):
                self.data.commanded_speed[current_line][block] = new_speed
        
        add_to_message_log(f"Commanded Speed updated to: {new_speed}")
        self.update_commanded_display()

    def update_commanded_display(self):
        """Update commanded values display"""
        selected_block = self.block_combo.get()
        current_line = self.data.current_line
        
        if selected_block and current_line:
            # Check shared data from RailwayData if available
            if hasattr(self.data, 'commanded_authority'):
                data_auth = self.data.commanded_authority.get(current_line, {}).get(selected_block)
                data_speed = self.data.commanded_speed.get(current_line, {}).get(selected_block)
                
                if data_auth is not None or data_speed is not None:
                    # Update entry fields with values from shared data
                    if data_auth is not None and self.auth_entry.get() != data_auth:
                        self.auth_entry.delete(0, tk.END)
                        self.auth_entry.insert(0, data_auth)
                    if data_speed is not None and self.speed_entry.get() != data_speed:
                        self.speed_entry.delete(0, tk.END)
                        self.speed_entry.insert(0, data_speed)
                    
                    # Update local storage
                    if data_auth is not None:
                        self.commanded_authority[current_line][selected_block] = data_auth
                    if data_speed is not None:
                        self.commanded_speed[current_line][selected_block] = data_speed
                    return
            
            # Fallback to local storage - update entry fields
            local_auth = self.commanded_authority.get(current_line, {}).get(selected_block)
            local_speed = self.commanded_speed.get(current_line, {}).get(selected_block)
            
            if local_auth is not None and self.auth_entry.get() != local_auth:
                self.auth_entry.delete(0, tk.END)
                self.auth_entry.insert(0, local_auth)
            
            if local_speed is not None and self.speed_entry.get() != local_speed:
                self.speed_entry.delete(0, tk.END)
                self.speed_entry.insert(0, local_speed)

    def update_suggested_speed(self, speed_value):
        """Update suggested speed from external source"""
        selected_block = self.block_combo.get()
        current_line = self.data.current_line
        
        if selected_block and current_line and speed_value is not None:
            self.suggested_speed[current_line][selected_block] = speed_value
            self.suggested_speed_label.config(text=f"{speed_value:.3f} mph")
            add_to_message_log(f"Suggested Speed updated to: {speed_value:.3f} mph")

    def update_suggested_authority(self, authority_value):
        """Update suggested authority from external source"""
        selected_block = self.block_combo.get()
        current_line = self.data.current_line
        
        if selected_block and current_line and authority_value is not None:
            self.suggested_authority[current_line][selected_block] = authority_value
            self.suggested_auth_label.config(text=f"{authority_value} blocks")
            add_to_message_log(f"Suggested Authority updated to: {authority_value} blocks")

    def create_block_table_section(self):
        """Create block status table section with horizontal scroll"""
        # Search frame
        search_frame = tk.Frame(self, bg='#1a1a4d')
        search_frame.pack(fill=tk.X, pady=5)
        self.block_search_var = tk.StringVar()
        self.block_search_var.trace('w', self.filter_block_table)
        block_search = tk.Entry(search_frame, textvariable=self.block_search_var, width=20)
        block_search.pack(side=tk.LEFT, padx=5)
        tk.Label(search_frame, text="Search", bg='#1a1a4d', fg='white', font=('Arial', 9)).pack(side=tk.LEFT)
   
        # Table container - FIXED HEIGHT to match other sections
        table_container = tk.Frame(self, bg='#1a1a4d', height=300)
        table_container.pack(fill=tk.BOTH, expand=True, pady=5)
        table_container.pack_propagate(False)  # Prevent container from shrinking
   
        # Create a frame for canvas and scrollbars
        canvas_frame = tk.Frame(table_container, bg='#1a1a4d')
        canvas_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        
        # Horizontal scrollbar (top)
        x_scrollbar = tk.Scrollbar(canvas_frame, orient="horizontal")
        x_scrollbar.pack(side="bottom", fill="x")
        
        # Vertical scrollbar (right)
        y_scrollbar = tk.Scrollbar(canvas_frame)
        y_scrollbar.pack(side="right", fill="y")
        
        # Canvas for scrolling with BOTH scrollbars
        self.table_canvas = tk.Canvas(canvas_frame, bg='white', highlightthickness=0,
                                     xscrollcommand=x_scrollbar.set,
                                     yscrollcommand=y_scrollbar.set)
        self.table_canvas.pack(side="left", fill="both", expand=True)
        
        # Configure scrollbars
        x_scrollbar.config(command=self.table_canvas.xview)
        y_scrollbar.config(command=self.table_canvas.yview)
        
        # Frame inside canvas for table content
        self.block_table_frame = tk.Frame(self.table_canvas, bg='white')
        self.canvas_window = self.table_canvas.create_window((0, 0), window=self.block_table_frame, anchor="nw")
        
        # Configure canvas to expand with container
        def configure_canvas(event):
            # Update canvas window width when canvas is resized
            self.table_canvas.itemconfig(self.canvas_window, width=event.width)
            # Update scroll region
            self.table_canvas.configure(scrollregion=self.table_canvas.bbox("all"))
        
        self.table_canvas.bind("<Configure>", configure_canvas)
        
        # Mousewheel scrolling for vertical only
        def _on_mousewheel(event):
            self.table_canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        self.table_canvas.bind("<MouseWheel>", _on_mousewheel)
        self.block_table_frame.bind("<MouseWheel>", _on_mousewheel)
        
        # Initial table creation
        self.create_block_table()

    def create_block_table(self):
        """Create block status table with compact layout"""
        # Clear existing widgets
        for widget in self.block_table_frame.winfo_children():
            widget.destroy()
        
        # Get filtered data for current line
        display_data = []
        if hasattr(self.data, 'filtered_block_data'):
            # Use filtered data for current line
            display_data = [row for row in self.data.filtered_block_data 
                          if row[1] == self.data.current_line]
        else:
            # Use all data for current line
            display_data = [row for row in self.data.block_data 
                          if row[1] == self.data.current_line]
        
        # Headers - 5 columns with COMPACT widths to fit
        headers_frame = tk.Frame(self.block_table_frame, bg='#cccccc')
        headers_frame.pack(fill=tk.X)
        
        # COMPACT column widths - adjusted to fit within panel width
        col_widths = {
            'occupied': 6,      # Reduced from 8
            'line': 4,          # Reduced from 4
            'block': 5,         # Reduced from 5
            'section': 5,       # Reduced from 6
            'infrastructure': 9 # Reduced from 14
        }
        
        # Occupied header
        tk.Label(headers_frame, text="Occ", bg='#cccccc',
                font=('Arial', 8, 'bold'), width=col_widths['occupied']).pack(side=tk.LEFT, padx=1)
        # Line header
        tk.Label(headers_frame, text="Line", bg='#cccccc',
                font=('Arial', 8, 'bold'), width=col_widths['line']).pack(side=tk.LEFT, padx=1)
        # Block header
        tk.Label(headers_frame, text="Block", bg='#cccccc',
                font=('Arial', 8, 'bold'), width=col_widths['block']).pack(side=tk.LEFT, padx=1)
        # Section header
        tk.Label(headers_frame, text="Sec", bg='#cccccc',
                font=('Arial', 8, 'bold'), width=col_widths['section']).pack(side=tk.LEFT, padx=1)
        # Infrastructure header (abbreviated)
        tk.Label(headers_frame, text="Infra", bg='#cccccc',
                font=('Arial', 8, 'bold'), width=col_widths['infrastructure']).pack(side=tk.LEFT, padx=1)
        
        # Data rows
        self.block_combos = []
        
        for row_index, row in enumerate(display_data):
            row_frame = tk.Frame(self.block_table_frame, bg='white')
            row_frame.pack(fill='x', pady=1)
            
            # Find actual index in full block_data
            try:
                actual_index = self.data.block_data.index(row)
            except ValueError:
                actual_index = row_index
            
            if self.data.maintenance_mode:
                # MAINTENANCE MODE - Editable occupancy
                # Occupied (editable combo)
                occ_combo = ttk.Combobox(row_frame, values=["Yes", "No"], 
                                      width=col_widths['occupied']-2)
                occ_combo.set(row[0])
                occ_combo.pack(side=tk.LEFT, padx=1)
                occ_combo.bind('<<ComboboxSelected>>',
                    lambda event, idx=actual_index, combo=occ_combo:
                    self.on_block_data_change(idx, 0, combo.get()))
                self.block_combos.append(occ_combo)
                
                # Line (read-only with color)
                bg_color = '#66cc66' if row[1] == "Green" else '#ff6666' if row[1] == "Red" else '#6666ff'
                tk.Label(row_frame, text=row[1], bg=bg_color, width=col_widths['line'],
                       borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
                
                # Block (read-only)
                tk.Label(row_frame, text=str(row[2]), bg='white', width=col_widths['block'],
                       borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
                
                # Section (read-only)
                tk.Label(row_frame, text=row[3], bg='white', width=col_widths['section'],
                       borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
                
                # Infrastructure (read-only, truncated if too long)
                infra_text = str(row[4])
                if len(infra_text) > 12:  # Truncate long infrastructure text
                    infra_text = infra_text[:10] + "..."
                tk.Label(row_frame, text=infra_text, bg='white', width=col_widths['infrastructure'],
                       borderwidth=1, relief=tk.GROOVE, anchor='w').pack(side=tk.LEFT, padx=1)
                
            else:
                # NORMAL MODE - all read-only
                # Occupied with color coding
                occupied_color = '#ff6666' if row[0] == "Yes" else '#ccffcc'
                tk.Label(row_frame, text=row[0], bg=occupied_color, width=col_widths['occupied'],
                       borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
                
                # Line with color
                bg_color = '#66cc66' if row[1] == "Green" else '#ff6666' if row[1] == "Red" else '#6666ff'
                tk.Label(row_frame, text=row[1], bg=bg_color, width=col_widths['line'],
                       borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
                
                # Block
                tk.Label(row_frame, text=str(row[2]), bg='white', width=col_widths['block'],
                       borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
                
                # Section
                tk.Label(row_frame, text=row[3], bg='white', width=col_widths['section'],
                       borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
                
                # Infrastructure (truncated if too long)
                infra_text = str(row[4])
                if len(infra_text) > 12:  # Truncate long infrastructure text
                    infra_text = infra_text[:10] + "..."
                tk.Label(row_frame, text=infra_text, bg='white', width=col_widths['infrastructure'],
                       borderwidth=1, relief=tk.GROOVE, anchor='w').pack(side=tk.LEFT, padx=1)

    def on_block_data_change(self, row_index, col_index, new_value):
        """Callback when block data is changed in maintenance mode"""
        self.data.update_block_data(row_index, col_index, new_value)
        
        # Update current block display if this is the selected block
        selected_block = self.block_combo.get()
        if selected_block:
            block_num = self.data.block_data[row_index][2]
            if str(block_num) == str(selected_block):
                self.update_current_block_info()
       
    def filter_block_table(self, *args):
        """Filter block table based on search term"""
        search_term = self.block_search_var.get().lower()
        self.data.filter_block_data(search_term)
        self.create_block_table()
   
    def update_mode_ui(self):
        """Refresh UI when maintenance mode changes"""
        self.create_block_table()
        self.update_current_block_info()
   
    def on_line_changed(self):
        """Refresh right panel when line changes"""
        self.update_block_options()
        self.create_block_table()
        self.update_current_block_info()
        self.update_suggested_display()
        self.update_commanded_display()
        
    def set_yard_to_station_commands(self):
        """Set hardcoded commanded values for yard to station"""
        current_line = "Green"
        
        # Outbound: Yard (63) to Station (96)
        blocks_outbound = list(range(63, 97))
        authority = len(blocks_outbound) - 1
        
        for block_num in blocks_outbound:
            self.commanded_authority[current_line][str(block_num)] = f"{authority} blocks"
            self.commanded_speed[current_line][str(block_num)] = "31 mph" if authority > 0 else "0 mph"
            authority -= 1
        
        # Return: Station (96) back to Yard (57)
        blocks_return = list(range(96, 56, -1))
        authority = len(blocks_return) - 1
        
        for block_num in blocks_return:
            self.commanded_authority[current_line][str(block_num)] = f"{authority} blocks"
            self.commanded_speed[current_line][str(block_num)] = "31 mph" if authority > 0 else "0 mph"
            authority -= 1
        
        # Final destinations
        self.commanded_authority[current_line]["96"] = "0 blocks"
        self.commanded_speed[current_line]["96"] = "0 mph"
        self.commanded_authority[current_line]["57"] = "0 blocks"
        self.commanded_speed[current_line]["57"] = "0 mph"
        
        # Update display if on Green line
        if self.data.current_line == "Green":
            self.update_commanded_display()





# # ---------- RIGHT PANEL ---------- #
# class RightPanel(tk.Frame):
#     def __init__(self, parent, data):
#         super().__init__(parent, bg='#1a1a4d', width=250)
#         self.pack_propagate(False)
#         self.data = data
        
#         #attributes for suggested speed/authority
#         self.suggested_speed_label = None
#         self.suggested_authority_label = None
#         # self.create_suggested_section()

#         # Connect line change callback
#         self.data.on_line_change.append(self.on_line_changed)
#         self.data.on_block_change.append(self.on_block_data_changed)

#          # Clear any search filters and show all data
#         if hasattr(self.data, 'filtered_block_data'):
#             self.data.filtered_block_data = self.data.block_data.copy()
#         self.create_widgets()
#     def on_block_data_changed(self, row_index, col_index, new_value):
#         # Update only the affected row in the table if maintenance mode
#         if self.data.maintenance_mode:
#             self.create_block_table()  # Simple approach: rebuild table
#         add_to_message_log(f"[Main UI] Block {self.data.block_data[row_index][2]} updated to {new_value}")
   
#     def create_widgets(self):
#         # Block selector
#         block_frame = tk.Frame(self, bg='#cccccc')
#         block_frame.pack(fill=tk.X, pady=5)
#         tk.Label(block_frame, text="Block", bg='#cccccc').pack(side=tk.LEFT, padx=5)
       
#         # Update block combo based on current line
#         self.block_combo = ttk.Combobox(block_frame, width=15, state='readonly')
#         self.block_combo.pack(side=tk.LEFT, padx=5)
#         self.update_block_options()

#         # Suggested section
#         self.create_suggested_section()
       
#         # Commanded section
#         self.create_commanded_section()
       
#         # Search and block table
#         self.create_block_table_section()

#     def update_block_options(self):
#         """Update block selector based on current line"""
#         blocks = [row[2] for row in self.data.block_data]
#         self.block_combo['values'] = blocks
#         if blocks:
#             self.block_combo.set(blocks[0])
   
#     def on_line_changed(self):
#         """Refresh right panel when line changes"""
#         print(f"Right panel: Line changed to {self.data.current_line}")
#         self.update_block_options()
#         self.create_block_table()
   
#     def create_suggested_section(self):
#         suggested_frame = tk.LabelFrame(self, text="Suggested:",
#                                        bg='#cccccc', font=('Arial', 10, 'bold'))
#         suggested_frame.pack(fill=tk.X, pady=5)
#        # Authority:
#         tk.Label(suggested_frame, text="Authority:", bg='#cccccc').pack(anchor='w', padx=5)
#         tk.Label(suggested_frame, text="0 blocks", bg='white',
#                 relief=tk.SUNKEN).pack(fill=tk.X, padx=5, pady=2)
#         #Speed:
#         tk.Label(suggested_frame, text="Speed:", bg='#cccccc').pack(anchor='w', padx=5)
#         tk.Label(suggested_frame, text="0.000 mph", bg='white',
#                 relief=tk.SUNKEN).pack(fill=tk.X, padx=5, pady=2)
   
#     def create_commanded_section(self):
#         commanded_frame = tk.LabelFrame(self, text="Commanded:",
#                                    bg='#cccccc', font=('Arial', 10, 'bold'))
#         commanded_frame.pack(fill=tk.X, pady=5)
   
#     # Authority section
#         auth_frame = tk.Frame(commanded_frame, bg='#cccccc')
#         auth_frame.pack(fill=tk.X, padx=5, pady=2)
#         tk.Label(auth_frame, text="Authority:", bg='#cccccc').pack(side=tk.LEFT)
   
#         self.auth_entry = tk.Entry(auth_frame, width=10)
#         self.auth_entry.insert(0, "2 blocks")  # Default value
#         self.auth_entry.pack(side=tk.LEFT, padx=2)
   
#         auth_button = tk.Button(auth_frame, text="Send", width=5, command=self.update_authority)
#         auth_button.pack(side=tk.LEFT)
   
#     # Speed section
#         speed_frame = tk.Frame(commanded_frame, bg='#cccccc')
#         speed_frame.pack(fill=tk.X, padx=5, pady=2)
#         tk.Label(speed_frame, text="Speed:", bg='#cccccc').pack(side=tk.LEFT)
   
#         self.speed_entry = tk.Entry(speed_frame, width=10)
#         self.speed_entry.insert(0, "38 mph")  # Default value
#         self.speed_entry.pack(side=tk.LEFT, padx=2)
   
#         speed_button = tk.Button(speed_frame, text="Send", width=5, command=self.update_speed)
#         speed_button.pack(side=tk.LEFT)

#     def update_authority(self):
#         """Update commanded authority and log the change"""
#         new_authority = self.auth_entry.get()
#         add_to_message_log(f"Commanded Authority updated to: {new_authority}")
#         # Here you would also update the backend data structure
#         # commanded_authority.append(new_authority)

#     def update_speed(self):
#         """Update commanded speed and log the change"""
#         new_speed = self.speed_entry.get()
#         add_to_message_log(f"Commanded Speed updated to: {new_speed}")
#     # Here you would also update the backend data structure
#     # commanded_speed.append(new_speed)
#     #######################################################################################################################
#     ######################################################################################################################
#     def update_suggested_speed(self, speed_value):
#     # """Update the suggested speed display with formatted value"""
#         try:
#             if speed_value is not None:
#                 formatted_speed = f"{speed_value:.3f} mph"
#                 self.suggested_speed_label.config(text=formatted_speed)
#                 add_to_message_log(f"Suggested Speed updated to: {formatted_speed}")
#             else:
#                 add_to_message_log(f"ERROR: Invalid speed value received", "ERROR")
#         except Exception as e:
#             add_to_message_log(f"ERROR updating speed display: {e}", "ERROR")

#     def update_suggested_authority(self, authority_value):
#         """Update the suggested authority display"""
#         try:
#             if authority_value is not None:
#                 formatted_authority = f"{authority_value} blocks"
#                 self.suggested_authority_label.config(text=formatted_authority)
#                 add_to_message_log(f"Suggested Authority updated to: {formatted_authority}")
#             # else:
#             #     add_to_message_log("ERROR: Invalid authority value received", "ERROR")
#         except Exception as e:
#             add_to_message_log(f"ERROR updating authority display: {e}", "ERROR")
#    ############################################################################################################################
#    ##############################################################################################################################
#     def create_block_table_section(self):
#     # Search
#         search_frame = tk.Frame(self, bg='#1a1a4d')
#         search_frame.pack(fill=tk.X, pady=5)
#         self.block_search_var = tk.StringVar()
#         self.block_search_var.trace('w', self.filter_block_table)
#         block_search = tk.Entry(search_frame, textvariable=self.block_search_var, width=20)
#         block_search.pack(side=tk.LEFT, padx=5)
#         tk.Label(search_frame, text="Search", bg='#1a1a4d', fg='white', font=('Arial', 9)).pack(side=tk.LEFT)
   
#     # Create scrollable table with fixed height
#         table_container = tk.Frame(self, bg='white', relief=tk.SUNKEN, borderwidth=2, height=300)
#         table_container.pack(fill=tk.BOTH, expand=True, pady=5)
#         table_container.pack_propagate(False)  # Prevent container from shrinking
   
#     # Canvas and scrollbar
#         canvas = tk.Canvas(table_container, bg='white', highlightthickness=0, width=350)
#         scrollbar = tk.Scrollbar(table_container, orient="vertical", command=canvas.yview)
#         self.block_table_frame = tk.Frame(canvas, bg='white')
    
#     # # Create a frame for canvas and scrollbar
#         # scroll_frame = tk.Frame(table_container, bg='white')
#         # scroll_frame.pack(fill=tk.BOTH, expand=True)
   
   
#     # Configure scrolling
#         self.block_table_frame.bind(
#             "<Configure>",
#             lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
#         )
   
#         canvas.create_window((0, 0), window=self.block_table_frame, anchor="nw")
#         canvas.configure(yscrollcommand=scrollbar.set)
   
#     # Pack canvas and scrollbar
#     # def configure_canvas(event):
#     #     canvas.itemconfig(canvas_window, width=event.width)
#     #     canvas.bind("<Configure>", configure_canvas)
#         canvas.pack(side="left", fill="both", expand=True)
#         scrollbar.pack(side="right", fill="y")
   
#     # Add mousewheel scrolling
#     def _on_mousewheel(self, event):
#         canvas.yview_scroll(int(-1*(event.delta/120)), "units")

#         # Force the table to be created immediately with ALL data
#         self.block_search_var.set("")  # Clear any search text
#         self.data.filter_block_data("")  # Show all data
#         return "break" # Prevent default scrolling
    
#         canvas.bind("<MouseWheel>", _on_mousewheel)
#         self.block_table_frame.bind("<MouseWheel>", _on_mousewheel)
#         table_container.bind("<MouseWheel>", _on_mousewheel)
#         # self.block_search_var.set("")  # Clear any search text
#         self.data.filter_block_data("")  # Show all data
#         self.create_block_table()

#     def create_block_table(self):
#         print(f"DEBUG: Creating block table in frame: {self.block_table_frame}")
#         # print(f"DEBUG: Frame width: {self.block_table_frame.winfo_width()}, height: {self.block_table_frame.winfo_height()}")

#     # Clear existing widgets
#         for widget in self.block_table_frame.winfo_children():
#             widget.destroy()
#      # Get the filtered data
#         block_data = self.data.get_block_table_data()

#         # print(f"DEBUG: Block data received: {len(block_data)} rows")
#         # if block_data:
#             # print(f"DEBUG: First row: {block_data[0]}")
#             # print(f"DEBUG: Row structure: {[len(row) for row in block_data]}")

#     # Headers - 4 columns
#         headers_frame = tk.Frame(self.block_table_frame, bg='#cccccc')
#         headers_frame.pack(fill=tk.X)
   
#     # define consistent widths for all columns
#         col_widths = {
#             'occupied': 8,
#             'line': 4,
#             'block': 5,
#             'section': 6,
#             'infrastructure': 14
#         }

#         tk.Label(headers_frame, text="Occupied", bg='#cccccc',
#             font=('Arial', 8, 'bold'), width=col_widths['occupied']).pack(side=tk.LEFT, padx=1)
#         tk.Label(headers_frame, text="Line", bg='#cccccc',
#             font=('Arial', 8, 'bold'), width=col_widths['line']).pack(side=tk.LEFT, padx=1)
#         tk.Label(headers_frame, text="Block", bg='#cccccc',
#             font=('Arial', 8, 'bold'), width=col_widths['block']).pack(side=tk.LEFT, padx=1)
#         tk.Label(headers_frame, text="Section", bg='#cccccc',
#             font=('Arial', 8, 'bold'), width=col_widths['section']).pack(side=tk.LEFT, padx=1)
#         tk.Label(headers_frame, text="Infrastructure", bg='#cccccc',
#             font=('Arial', 8, 'bold'), width=col_widths['infrastructure']).pack(side=tk.LEFT, padx=1)
#     # Data rows
#         self.block_combos = []  # Store references to comboboxes

#         # Use filtered data for display
#         display_data = self.data.filtered_block_data if hasattr(self.data, 'filtered_block_data') else self.data.block_data

#         for row_index, row in enumerate(display_data):
#             # print(f"DEBUG: Processing row {row_index}: {row}")
#             row_frame = tk.Frame(self.block_table_frame, bg='white')
#             row_frame.pack(fill='x', pady=1)
#             try:
#                 while len(row) < 5:
#                     row.append("")  # Add empty strings for missing columns

#                 if self.data.maintenance_mode:
#             # Editable in maintenance mode - OCCUPIED COMBO
#                     occ_combo = ttk.Combobox(row_frame, values=["Yes", "No"], width=col_widths['occupied']-2)
#                     occ_combo.set(row[0])
#                     occ_combo.pack(side=tk.LEFT, padx=1)

#             # Bind the change event to update data model
#                     occ_combo.bind('<<ComboboxSelected>>',
#                         lambda event, idx=row_index, combo=occ_combo:
#                         self.on_block_data_change(idx, 0, combo.get()))
           
#             # LINE - READ ONLY (track color should not change)
#                     bg_color = '#66cc66' if row[1] == "Green" else '#ff6666' if row[1] == "Red" else '#6666ff'
#                     tk.Label(row_frame, text=row[1], bg=bg_color, width=col_widths['line'],
#                     borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
           
#             # Block number (read-only)
#                     tk.Label(row_frame, text=row[2], bg='white', width=col_widths['block'],
#                     borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
            
#             # Section letter (read-only)
#                     tk.Label(row_frame, text=row[3], bg='white', width=col_widths['section'],
#                     borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
             
#             #  Infrastructure (read-only) 
#                     tk.Label(row_frame, text=str(row[4]), bg='white', width=col_widths['infrastructure'],
#                     borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
#             # Store combos for potential access
#                     self.block_combos.append(occ_combo)
           
#                 else:
#             # print(f"DEBUG: Creating normal mode labels for block {row[2]}")
#                     tk.Label(row_frame, text=row[0], bg='white', width=col_widths['occupied'],
#                     borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
            
#                     bg_color = '#66cc66' if row[1] == "Green" else '#ff6666' if row[1] == "Red" else '#6666ff'
#                     tk.Label(row_frame, text=row[1], bg=bg_color, width=col_widths['line'],
#                     borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
            
#                     tk.Label(row_frame, text=row[2], bg='white', width=col_widths['block'],
#                     borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
            
#                     tk.Label(row_frame, text=row[3], bg='white', width=col_widths['section'],
#                     borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)

#                     tk.Label(row_frame, text=str(row[4]), bg='white', width=col_widths['infrastructure'],
#                     borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
#             except Exception as e:
#                 print(f"Error creating row {row_index}: {e} - Row data: {row}")
    
#         # if i < 3:  # Debug first 3 rows
#         #     print(f"DEBUG: Created row {i}: {row}")
    
#         # print(f"DEBUG: Finished creating {len(block_data)} rows")
#     # Force update
#         self.block_table_frame.update()            
#     # print("DEBUG: Finished creating block table")

#     def on_block_data_change(self, row_index, col_index, new_value):
#         """Callback when any block data is changed in maintenance mode"""
#         print(f"Block data changed: row {row_index}, col {col_index}, value '{new_value}'")
#         self.data.update_block_data(row_index, col_index, new_value)
       
#     def filter_block_table(self, *args):
#         search_term = self.block_search_var.get().lower()
#         self.data.filter_block_data(search_term)
#         self.create_block_table()
   
#     def update_mode_ui(self):
#         """Refresh block table when mode changes"""
#         self.create_block_table()
#############################################################################################################
################################################################################################################
    
#############################################################################################################
################################################################################################################
# Create the right panel with mock data
right_panel = RightPanel(main_frame, test_data)
right_panel.pack(side="right", fill="y", padx=5, pady=5)

# ---------- MAINTENANCE SCREEN (simple placeholder) ---------- #
maint_label = tk.Label(maintenance_frame, text="Maintenance Mode Active", bg="#0b1443", fg="white", font=("Arial", 24))
maint_label.place(relx=0.3, rely=0.4)

# Raise main screen by default
main_frame.tkraise()

root.mainloop()