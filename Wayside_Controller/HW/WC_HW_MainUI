import tkinter as tk
from tkinter import ttk, filedialog, messagebox, simpledialog
from datetime import datetime
from PIL import Image, ImageTk
from plc_controller import PLCController
import os, sys
# import green_line
# import red_line

# from Clock import clock
sys.path.insert(1, os.path.abspath(os.path.join(os.path.dirname(__file__), "../..")))
import clock
from TrainSocketServer import TrainSocketServer
########################################################################################################################


# Backend Data Structures (same as before)

commanded_speed = []
commanded_authority = []
switch_positions = []
light_states = []
block_occupancy = []

blocks = []
track_direction = []
railway_crossing = []
# heaters_work = []

switch_locations = []
light_location = []
railway_location = []
station_location = []

# environmental_temp: float
# failure_modes = []
# track_circuit_fail: bool
# railway_crossing_fail: bool
# power_fail: bool

# ticket_sales = []
# passengers_boarding = []
# passengers_disembarking = []
# train_occupancy = []
# active_trains = []
######
##############

def handle_ctc_suggested_speed(speed_data):
    """
    Handle CTC suggested speed messages and convert to float with 3 decimal places
    Expected formats:
    - String: "track HW", {"Suggested_speed", "float: new_speed"}
    - Dictionary: {'Suggested_speed': 'float: 45.5'}
    - Direct string: "float: 45.5"
    """
    try:
        suggested_speed = None
        
        # Handle different input formats
        if isinstance(speed_data, str):
            # Extract float value from string format
            if "float:" in speed_data:
                # Find the float value in the string
                import re
                float_match = re.search(r'float:\s*([0-9]*\.?[0-9]+)', speed_data)
                if float_match:
                    speed_str = float_match.group(1)
                    suggested_speed = float(speed_str)
            else:
                # Try direct conversion if it's just a number string
                suggested_speed = float(speed_data)
                
        elif isinstance(speed_data, dict):
            # Handle dictionary format
            if 'Suggested_speed' in speed_data:
                speed_value = speed_data['Suggested_speed']
                if isinstance(speed_value, str) and "float:" in speed_value:
                    speed_str = speed_value.split("float:")[1].strip()
                    suggested_speed = float(speed_str)
                else:
                    suggested_speed = float(speed_value)
            elif 'value' in speed_data:
                # Alternative dictionary format
                suggested_speed = float(speed_data['value'])
        
        # Format to 3 decimal places if conversion was successful
        if suggested_speed is not None:
            formatted_speed = round(suggested_speed, 3)
            add_to_message_log(f"CTC Suggested Speed Received: {formatted_speed:.3f} mph")
            return formatted_speed
        else:
            add_to_message_log("ERROR: Could not extract speed from CTC message", "ERROR")
            
    except ValueError as e:
        add_to_message_log(f"ERROR: Invalid speed format - {e}", "ERROR")
    except Exception as e:
        add_to_message_log(f"ERROR: Processing CTC speed message - {e}", "ERROR")
    
    return None

def update_suggested_speed_display(speed):
    """Update the suggested speed display in the right panel"""
    try:
        if hasattr(right_panel, 'update_suggested_speed'):
            right_panel.update_suggested_speed(speed)
        else:
            # Fallback: try to find and update the label directly
            formatted_speed = f"{speed:.3f} mph"
            add_to_message_log(f"CTC Speed received (UI update pending): {formatted_speed}")
    except Exception as e:
        add_to_message_log(f"ERROR updating speed display: {e}", "ERROR")


# installing update_callback function
def update_callback(message):
    """Socket server callback function"""
    print(f"Socket message recieved: {message}")
    add_to_message_log(f"Socket: {message}")

# send_to_ui function
# target ui is test ui

#Example of Process Function:
def _process_message(self, data, connection=None, server_instance=None):
    """Process incoming messages from Test UI"""
    try:
        print(f"=== MAIN UI DEBUG ===")
        print(f"Received data: {data}")
        print(f"=== END DEBUG ===")
         # Parse the data if it's a string
        if isinstance(data, str):
            try:
                # Try to parse as JSON
                parsed_data = json.loads(data)
                print(f"Parsed JSON data: {parsed_data}")
                message_data = parsed_data
            except json.JSONDecodeError:
                # If it's not JSON, treat it as a plain string message
                print(f"Data is plain string, not JSON: {data}")
                message_data = {'message': data}
        else:
            # Data is already a dictionary
            message_data = data
        
        # Handle different commands
        if command == 'ctc_suggestion':
            # Use your existing function
            formatted_speed = self.handle_ctc_suggested_speed(value)
            if formatted_speed is not None:
                self.update_suggested_speed(formatted_speed)
                # ADD THIS LINE - sync back to Test UI
                self.sync_speed_to_test_ui(formatted_speed)
        
        # Extract the actual message
        message = message_data.get('message', message_data)
        source_ui_id = message_data.get('ui_id', 'Unknown')
        
        print(f"Processing message from {source_ui_id}: {message}")
        
        # Extract message and source UI ID
        if isinstance(data, 'dict'):
            message = data.get('message', data)
            source_ui_id = data.get('WC_HW_TestUI', 'Unknown')
        else:
            message = data
            source_ui_id = 'WC_HW_TestUI'
        
        print(f"Processing message from {source_ui_id}: {message}")
        
        command = message.get('command')
        value = message.get('value')
        
        # Handle different commands
        if command == 'ctc_suggestion':
            self.handle_ctc_suggestion(value)
        elif command == 'set_block_occupancy':
            self.handle_block_occupancy(value)
        elif command == 'set_switch_position':
            self.handle_switch_position(value)
        elif command == 'some_command':
            print(f"Test command received with value: {value}")
        else:
            print(f"Unknown command: {command}")
            
    except Exception as e:
        print(f"Error processing message: {e}")
    

    def sync_speed_to_test_ui(self, speed_value):
        """Sync speed changes back to Test UI"""
        try:
            if hasattr(self, 'server1') and self.server1:
                message = {
                'command': 'sync_suggested_speed',
                'value': str(speed_value),
                'ui_id': 'WC_HW_MainUI'
            }
                self.server1.send_to_ui("WC_HW_TestUI", message)
        except Exception as e:
            print(f"Error syncing speed to Test UI: {e}")

class Clock:
    def __init__(self):
        self._fastTime = strftime("%H:%M:%S")
        self._incTimer = Timer(0.1, self._incTime)
        self._incTimer.start()

    def _incTime(self):
        self._incTimer = Timer(0.1, self._incTime)
        self._incTimer.start()

        hours = int(self._fastTime[:2])
        mins = int(self._fastTime[3:5])
        secs = int(self._fastTime[6:])

        secs += 1
        #increment fast time by 1 second every 100 ms

        if (secs == 60):
            secs = 0
            mins += 1

            if (mins == 60):
                mins = 0
                hours += 1

                if (hours == 24):
                    hours = 0

        self._fastTime = f"{hours:02d}:{mins:02d}:{secs:02d}"
    
    def getTime(self):
        return self._fastTime[:5]
    
    def endTimer(self):
        self._incTimer.cancel()


# Enhanced Mock data class for both panels
class UITestData:
    def __init__(self):
        # Define your block to section mapping
        self.block_sections = {
            "74": "M", "75": "M", "76": "M",
            "77": "N", "78": "N", "79": "N", "80": "N", "81": "N", "82": "N", "83": "N", "84": "N", "85": "N",
            "86": "O", "87": "O", "88": "O",
            "89": "P", "90": "P", "91": "P", "92": "P", "93": "P", "94": "P", "95": "P", "96": "P", "97": "P",
            "98": "Q", "99": "Q", "100": "Q",
            "101": "R",
            "102": "S", "103": "S", "104": "S",
            "105": "T", "106": "T", "107": "T", "108": "T", "109": "T",
            "110": "U", "111": "U", "112": "U", "113": "U", "114": "U", "115": "U", "116": "U",
            "117": "V", "118": "V", "119": "V", "120": "V", "121": "V",
            "122": "W", "123": "W", "124": "W", "125": "W", "126": "W", "127": "W", "128": "W", 
            "129": "W", "130": "W", "131": "W", "132": "W", "133": "W", "134": "W", "135": "W",
            "136": "W", "137": "W", "138": "W", "139": "W", "140": "W", "141": "W", "142": "W", "143": "W",
            "144": "X", "145": "X", "146": "X",
            "147": "Y", "148": "Y", "149": "Y",
            "150": "Z"
        }
        
        # Initialize ALL data attributes first
        self.track_data = {
            "crossings": {
                "Railway Crossing: 108": {"condition": "Normal", "lights": "Red", "bar": "Closed"}
            },
            "switches": {
                "Switch 76-77": {"condition": "Normal", "direction": "Blocks 76-77"},
                "Switch 85-86": {"condition": "Normal", "direction": "Blocks 85-86"}
            },
            "lights": {
                "Light 76": {"condition": "Normal", "signal": "Green"},
                "Light 85": {"condition": "Normal", "signal": "Yellow"},
                "Light 108": {"condition": "Normal", "signal": "Red"}
            }
        }

           # Sample block data: [Occupied, Line, Block]
        self.block_data = self.load_complete_track_data("green_line.txt")
        self.filtered_block_data = self.block_data.copy()

    
         # Initialize filtered_track_data by copying track_data
        self.filtered_track_data = self.track_data.copy()
   
        # Initialize block_data (make sure this exists too)
        # self.block_data = []  # Add your actual block data here
        self.filtered_block_data = self.block_data.copy()

        # SOCKET SERVER
        self.server1 = TrainSocketServer(port=12345, ui_id="WC_HW_MainUI")
        self.server1.set_allowed_connections(["WC_HW_TestUI", "ui_3"])
        self.server1.start_server(_process_message)
        
        # Connect to other UIs
        self.server1.connect_to_ui('localhost', 12346, "WC_HW_TestUI")

        # Current line
        self.current_line = "Green"
        # Maintenance mode
        self.maintenance_mode = False
        # Callbacks
        self.on_line_change = []
        self.on_block_change = []

        self.maintenance_changes = {
            "switches": True,
            "lights": False,
            "crossing": False,
            "block_occupancy": False
        }

        # Call this after a short delay
        if hasattr(self, 'root'):
            self.root.after(2000, self.verify_server_running)

    def load_complete_track_data(self, filename="green_line.txt"):
        """Load all green line blocks, merging sections where available"""
        complete_data = []

        try:
            import os
        
            print(f"Loading track data from: {filename}")
            print(f"File exists: {os.path.exists(filename)}")
            print(f"block_sections defined: {hasattr(self, 'block_sections')}")

        # Simple file read
            with open(filename, 'r') as file:
                lines = file.readlines()
        
            print(f"SUCCESS: Read {len(lines)} lines from {filename}")
            
            for line in lines[1:]:  # Skip header line
                    line = line.strip()
                    if line:
                        parts = line.split(',')
                    if len(parts) >= 3:
                        line_name = parts[0].strip()
                        block_number = parts[1].strip()
                        infrastructure = parts[2].strip()
                        
                        # Get section letter from mapping (empty string if not in your list)
                        section = self.block_sections.get(block_number, "")
                        
                        # Create block entry in your format
                        block_entry = ["No", line_name, block_number, section, infrastructure]
                        complete_data.append(block_entry)
            
                        print(f"DEBUG: Added block {block_number}: {block_entry}")
                    else:
                        print(f"DEBUG: Skipping line {line_num} - not enough parts: {parts}")            
            
            print(f"Loaded complete track data for {len(complete_data)} blocks")
            return complete_data

        except FileNotFoundError:
            print(f"Error: File {filename} not found")
            return []
        except Exception as e:
            print(f"Error loading complete track data: {e}")
            return []

    def verify_server_running(self):
        """Verify the socket server is actually running"""
        if hasattr(self, 'server1') and self.server1:
            print(f"=== SERVER VERIFICATION ===")
            print(f"Server running: {self.server1.running}")
            print(f"Server port: 12345")
            print(f"UI ID: {self.server1.ui_id}")
            print(f"Allowed connections: {self.server1.allowed_connections}")
        
        # Test if server socket is bound
        if hasattr(self.server1, 'server_socket'):
            print(f"Server socket: {self.server1.server_socket}")
            if self.server1.server_socket:
                print(f"Socket bound: {self.server1.server_socket.fileno() != -1}")
        print(f"=== END VERIFICATION ===")

    def create_clock_display(self, parent_frame):
        """Create a clock display in the UI"""
        clock_frame = tk.Frame(parent_frame, bg='#1a1a4d')
        clock_frame.pack(side=tk.TOP, fill=tk.X, pady=5)
        
        # Clock label
        self.clock_label = tk.Label(clock_frame, text="", 
                                   font=("Arial", 12, "bold"), 
                                   bg='#1a1a4d', fg='white')
        self.clock_label.pack(side=tk.RIGHT, padx=10)
        
        # Start updating the clock display
        self.update_clock_display()
    
    def update_clock_display(self):
        """Update the clock display every second"""
        try:
            current_time = self.clock.getTime()
            self.clock_label.config(text=f"Time: {current_time}")
        except Exception as e:
            print(f"Clock error: {e}")
            self.clock_label.config(text="Time: --:--")
        
        # Update every second
        self.clock_label.after(1000, self.update_clock_display)

    def on_closing(self):
        print("Closing application...")
        try:
            self.clock.endTimer()
        except:
            pass

        # Properly stop the socket server with comprehensive cleanup
        if hasattr(self, 'server1') and self.server1:
            try:
                # 1. First, notify connected clients
                if hasattr(self.server1, 'connections'):
                    disconnect_msg = {
                        'command': 'server_shutdown',
                        'message': 'Main UI is closing',
                        'timestamp': time.time()
                    }
                    for ui_id, connection in list(self.server1.connections.items()):
                        try:
                            self.server1.send_to_ui(ui_id, disconnect_msg)
                        except:
                            pass
                
                # 2. Stop accepting new connections
                self.server1.running = False
                
                # 3. Close all active connections
                if hasattr(self.server1, 'connections'):
                    for ui_id, connection in list(self.server1.connections.items()):
                        try:
                            if hasattr(connection, 'close'):
                                connection.close()
                        except Exception as e:
                            print(f"Error closing connection to {ui_id}: {e}")
                    self.server1.connections.clear()
                
                # 4. Close the server socket
                if hasattr(self.server1, 'server_socket') and self.server1.server_socket:
                    try:
                        self.server1.server_socket.close()
                        print("Server socket closed")
                    except Exception as e:
                        print(f"Error closing server socket: {e}")
                
                # 5. Stop any running threads
                if hasattr(self.server1, 'listen_thread') and self.server1.listen_thread:
                    try:
                        self.server1.listen_thread.join(timeout=2.0)
                    except Exception as e:
                        print(f"Error joining listen thread: {e}")
                
                print("Socket server shutdown complete")
                
            except Exception as e:
                print(f"Error during socket server shutdown: {e}")
        
        # 6. Finally, destroy the root window
        if hasattr(self, 'root') and self.root:
            try:
                self.root.destroy()
                print("Root window destroyed")
            except Exception as e:
                print(f"Error destroying root window: {e}")
        
        print("Application closed successfully")

    def get_block_table_data(self):
        return self.filtered_block_data

    def update_block_data(self, row_index, col_index, new_value):
        if 0 <= row_index < len(self.block_data):
            self.block_data[row_index][col_index] = new_value
            print(f"Updated block data: row {row_index} = {self.block_data[row_index]}")
            # Trigger callbacks
            for callback in self.on_block_change:
                callback(row_index, col_index, new_value)

    def filter_block_data(self, search_term):
        if not search_term or search_term.strip() == "":
            self.filtered_block_data = self.block_data.copy()
        else:
            self.filtered_block_data = [
                row for row in self.block_data
                if any(search_term in str(cell).lower() for cell in row)
            ]
   
    def is_changeable(self, component_type):
        """Check if a component type can be edited in current mode"""
        if not self.maintenance_mode:
            return False
        return self.maintenance_changes.get(component_type, False)

# Create mock data instance
test_data = UITestData()
# Temporary safety check - ensure filtered_track_data exists
if not hasattr(test_data, 'filtered_track_data'):
    print("Warning: filtered_track_data not found, creating it now...")
    test_data.filtered_track_data = test_data.track_data.copy() if hasattr(test_data, 'track_data') else {"switches": {}, "lights": {}, "crossings": {}}
#######################################################################################################################


# Root window setup
root = tk.Tk()
root.title("Wayside Controller Hardware UI")
root.geometry("1400x900")
root.configure(bg="#0b1443")

# ========== HEADER ========== #
header_frame = tk.Frame(root, bg="#0b1443")
header_frame.pack(fill="x", pady=10)

# Load and display the BLT logo
try:
    # Debug: Check current directory and file existence
    current_dir = os.getcwd()
    print(f"Current working directory: {current_dir}")
    
    # List all files in current directory
    print("Files in current directory:")
    for file in os.listdir(current_dir):
        print(f"  - {file}")
    
    # Check if file exists
    logo_path = "/home/siram/TRAINS-TEAM2/blt logo.png"
    print(f"Looking for logo at: {logo_path}")
    print(f"Logo file exists: {os.path.exists(logo_path)}")
    
    # Load the image and resize it appropriately
    logo_image = Image.open(logo_path)
    logo_image = logo_image.resize((60, 60), Image.Resampling.LANCZOS)
    logo_photo = ImageTk.PhotoImage(logo_image)
   
    # Create label with image
    logo = tk.Label(header_frame, image=logo_photo, bg="#0b1443")
    logo.image = logo_photo  # Keep a reference to prevent garbage collection
    logo.pack(side="left", padx=15)
    print("SUCCESS: Logo loaded successfully!")
    
except Exception as e:
    # Fallback to text if image loading fails
    print(f"Error loading logo: {e}")
    logo = tk.Label(header_frame, text="ðŸš‰", bg="#0b1443", fg="white", font=("Arial", 20))
    logo.pack(side="left", padx=15)

#creating a frame to contain buttons and status of PLC
plc_upload_btn = tk.Button(header_frame, text="Select PLC File", font=("Arial", 11, "bold"),
    width=16, height=2, command=lambda: select_plc_file())
plc_upload_btn.pack(side="left", padx=20)

run_plc_btn = tk.Button(
    header_frame,
    text="Run PLC",
    font=("Arial", 11, "bold"),
    width=16,
    height=2,
    bg="#008000",
    fg="white",
    command=lambda: run_plc_file()
)
run_plc_btn.pack(side="left", padx=10)

# creating a center frame for additonal buttons
center_frame = tk.Frame(header_frame, bg="#0b1443")
center_frame.pack(side="left", expand=True)

#add reference map


# Clock - positioned between PLC buttons and LEDs
clock_frame = tk.Frame(header_frame, bg="#0b1443")
clock_frame.pack(side=right, padx=15)
clock_label = tk.Label(
    header_frame, 
    text=clock_instance.getTime(), 
    font=("Arial", 12, "bold"), 
    bg="#0b1443", 
    fg="white")
clock_label.pack(side="right", anchor="ne")

# Fault LED indicator
fault_led = tk.Label(header_frame, text="Fault LED", bg="gray", fg="white", width=10, font=("Arial", 10, "bold"))
fault_led.pack(side="right", padx=30)

# Maintenance Mode LED indicator:
maint_led = tk.Label(header_frame, text="MM OFF", bg="gray", fg="white", width=10, font=("Arial", 10, "bold"))
maint_led.pack(side="right", padx=10)

#PLC Upload LED indicator:
plc_LED = tk.Label(header_frame, text="PLC Ready", bg="gray", fg="black", font=("Arial", 10, "bold"))
plc_LED.pack(side="left", padx=0)

# PLC upload and run buttons
def trigger_plc_fault():
    """Simulate a railroad crossing fault (PLC triggered)."""
    plc_instance.set_crossing_fault(True)
    fault_led.config(bg="red", text="FAULT")  # Turn LED red

def clear_plc_fault():
    """Clear the railroad crossing fault."""
    plc_instance.set_crossing_fault(False)
    fault_led.config(bg="green", text="OK")  # Turn LED green

selected_plc_file = None
plc_instance = None

def update_clock_display():
    """Continuously update the clock display every second"""
    # try:
    #     current_time = clock_instance.getTime()
    #     clock_label.config(text=current_time)
    # except Exception as e:
    #     print(f"Clock error: {e}")
    #     clock_label.config(text="--:--")
    time = clock.clock.getTime()
    self.clockText.configure(text = time)
    self.clockTimer = self.root.after(100, self.updateTime)

# update_clock_display()

#######################################################################################
#######################################################################################
# ========== BODY ========== #
body_frame = tk.Frame(root, bg="#0b1443")
body_frame.pack(fill="both", expand=True, padx=15, pady=10)

# Two main pages (stacked)
main_frame = tk.Frame(body_frame, bg="#0b1443")
maintenance_frame = tk.Frame(body_frame, bg="#0b1443")

for frame in (main_frame, maintenance_frame):
    frame.place(relwidth=1, relheight=1)

#######################################################################################
#######################################################################################
# ---------- CENTER AREA (Map + Message Log) ---------- #
center_container = tk.Frame(main_frame, bg="#0b1443")
center_container.pack(side="left", fill="both", expand=True, padx=5, pady=5)

# Map Display
map_frame = tk.Frame(center_container, bg="white", relief="ridge", borderwidth=3, width=750, height=650)
map_frame.pack(fill="none", expand=False)  # Don't expand, use fixed size
map_frame.pack_propagate(False)  # Prevent frame from shrinking to fit contents
##
# Create canvas for displaying the track image
canvas = tk.Canvas(map_frame, bg="white")
canvas.pack(fill="both", expand=True)
###########################################################################################################
##########################################################################################################
# Load and display the Red Green Blue Line track image
# try:
#     track_image = Image.open("./home/siram/TRAINS-TEAM2/Red and Green Line.png")
#     # Resize image to fit the canvas while maintaining aspect ratio
#     track_image = track_image.resize((700, 400), Image.Resampling.LANCZOS)
#     track_photo = ImageTk.PhotoImage(track_image)
   
#     # Display image on canvas
#     canvas.create_image(360, 215, image=track_photo)
#     canvas.image = track_photo  # Keep a reference to prevent garbage collection
   
# except Exception as e:
#     # Fallback if image loading fails
#     print(f"Error loading track image: {e}")
#     canvas.create_text(400, 250, text="TRACK MAP DISPLAY\n(Red and Green Line.png not found)",
#                       fill="black", font=("Arial", 14, "bold"), justify="center")

# Load and display the Green Line track image
try:
    # Debug: Check current directory and file existence
    current_dir = os.getcwd()
    print(f"Current working directory: {current_dir}")
    
    # List all files in current directory
    print("Files in current directory:")
    for file in os.listdir(current_dir):
        print(f"  - {file}")
    
    # Check if file exists in TRAINS-TEAM2 folder
    image_path = "/home/siram/TRAINS-TEAM2/Red and Green Line.png"
    print(f"Looking for image at: {image_path}")
    print(f"File exists: {os.path.exists(image_path)}")
    
    track_image = Image.open(image_path)
    # Resize image to fit the canvas while maintaining aspect ratio
    track_image = track_image.resize((700, 600), Image.Resampling.LANCZOS)
    track_photo = ImageTk.PhotoImage(track_image)
   
    # Display image on canvas
    canvas.create_image(375, 300, image=track_photo)
    canvas.image = track_photo  # Keep a reference to prevent garbage collection
    print("SUCCESS: Image loaded successfully!")
   
except Exception as e:
    # Fallback if image loading fails
    print(f"Error loading track image: {e}")
    canvas.create_text(400, 250, text="TRACK MAP DISPLAY\n(Red and Green Line.png not found)",
                      fill="black", font=("Arial", 14, "bold"), justify="center")
#######################################################################################################
#######################################################################################################

# Add the MessageLogger class definition right after your imports
class MessageLogger:
    def __init__(self, text_widget):
        self.text_widget = text_widget
       
    def log(self, message, level="INFO"):
        """Add timestamped message with color coding"""
        self.text_widget.config(state="normal")
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        color = self.get_color_for_level(level)
        self.text_widget.insert("end", f"{timestamp} [{level}] {message}\n")
        self.text_widget.tag_config(level, foreground=color)
        self.text_widget.see("end")
        self.text_widget.config(state="disabled")
   
    def get_color_for_level(self, level):
        colors = {"INFO": "white", "WARNING": "yellow", "ERROR": "red", "DEBUG": "cyan"}
        return colors.get(level, "white")
   
    def clear(self):
        self.text_widget.config(state="normal")
        self.text_widget.delete(1.0, "end")
        self.text_widget.config(state="disabled")

# Message Log (now underneath the map)
message_frame = tk.Frame(center_container, bg="#0b1443", height=150)
message_frame.pack(fill="x", pady=(10, 0))

tk.Label(message_frame, text="Messages", bg="#0b1443", fg="white", font=("Arial", 12, "bold")).pack(anchor="w", padx=5)

# Create a frame for the text widget with scrollbar
log_container = tk.Frame(message_frame, bg="#0b1443")
log_container.pack(fill="x", pady=5)

log_text = tk.Text(log_container, height=6, bg="#111b52", fg="white", font=("Courier", 10))
scrollbar = tk.Scrollbar(log_container, orient="vertical", command=log_text.yview)
log_text.configure(yscrollcommand=scrollbar.set)

log_text.pack(side="left", fill="x", expand=True)
scrollbar.pack(side="right", fill="y")

# Create MessageLogger instance
message_logger = MessageLogger(log_text)

# Keep this function for backward compatibility with existing code
def add_to_message_log(message):
    """Wrapper for backward compatibility"""
    message_logger.log(message, "INFO")

# plc = PLCController(add_to_message_log)
# plc_instance = PLCController(add_to_message_log)
# plc_instance.main()  # Runs PLC logic
#
# Initialize with some messages
add_to_message_log("INFO: UI initialized.")
add_to_message_log("INFO: Map display loaded.")
add_to_message_log("INFO: Control panels ready.")
###########################################################################################
############################      PLC MANAGER  ############################################

# Add PLCManager class definition after MessageLogger
class PLCManager:
    def __init__(self, message_logger):
        self.message_logger = message_logger
        self.plc_instance = None
        self.current_file = None
       
    def load_plc_file(self, file_path):
        try:
            import importlib.util
            spec = importlib.util.spec_from_file_location("plc_module", file_path)
            plc_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(plc_module)
           
            self.plc_instance = plc_module.PLCController(self.message_logger.log)
            self.current_file = file_path
            self.message_logger.log(f"PLC file loaded: {file_path}", "INFO")
            return True
        except Exception as e:
            self.message_logger.log(f"PLC load error: {e}", "ERROR")
            return False
   
    def run_plc(self):
        if not self.plc_instance:
            self.message_logger.log("No PLC file loaded", "WARNING")
            messagebox.showwarning("No PLC File", "Please upload a PLC file first!")
            return False
       
        try:
            self.plc_instance.main()
            self.message_logger.log(f"PLC file executed: {self.current_file.split('/')[-1]}", "INFO")
            return True
        except Exception as e:
            self.message_logger.log(f"PLC runtime error: {e}", "ERROR")
            return False
   
    def get_status(self):
        return {
            "loaded": self.plc_instance is not None,
            "file": self.current_file
        }
   
#creating mock data instance
test_data = UITestData()  

# Creating MessageLogger
message_logger = MessageLogger(log_text)

# Create PLCManager instance (after message_logger is created)
plc_manager = PLCManager(message_logger)

# Update the button functions:
def select_plc_file():
    """Open a file dialog to select a PLC file"""
    file_path = filedialog.askopenfilename(
        title ="Select PLC File",
        filetypes=[("Python Files", "*.py")]
    )
    if file_path:
        if plc_manager.load_plc_file(file_path):
            # Update LED or other UI elements if needed
            plc_LED.config(bg="white", text="PLC LOADED")

def run_plc_file():
    """Run the PLC logic using the selected file."""
    if plc_manager.run_plc():
        plc_LED.config(bg="green", text="PLC RUNNING")
    else:
        plc_LED.config(bg="red", text="FAULT")

# Keep global plc_instance for backward compatibility
plc_instance = None  # This will be set by PLCManager internally

# Update buttons
plc_upload_btn.config(command=select_plc_file)
run_plc_btn.config(command=run_plc_file)

#########################################################################################
#########################################################################################

# Screen toggle checkboxes
toggle_frame = tk.Frame(header_frame, bg="#0b1443")
toggle_frame.pack(side="right", padx=30)

view_var_main = tk.BooleanVar(value=True)
view_var_maint = tk.BooleanVar(value=False)

def update_screen_view():
    if view_var_main.get():
        main_frame.tkraise()
        # When switching to main screen, update maintenance mode based on maint_check
        test_data.maintenance_mode = view_var_maint.get()
        if hasattr(right_panel, 'update_mode_ui'):
            right_panel.update_mode_ui()
    elif view_var_maint.get():
        maintenance_frame.tkraise()

main_check = tk.Checkbutton(toggle_frame, text="Main Screen", variable=view_var_main,
                            command=lambda: [view_var_maint.set(False), update_screen_view()],
                            bg="#0b1443", fg="white", selectcolor="#333", font=("Arial", 10))
main_check.grid(row=0, column=0, padx=10)

def toggle_maintenance_mode():
    """Toggle maintenance mode when Maintenance checkbox is clicked"""
    test_data.maintenance_mode = view_var_maint.get()

    # Update the maintenance LED color/text
    if test_data.maintenance_mode:
        maint_led.config(bg="orange", text="MM ON")
    else:
        maint_led.config(bg="gray", text="MM OFF")

    # Update the right panel UI
    if hasattr(right_panel, 'update_mode_ui'):
        right_panel.update_mode_ui()

    # Keep the main screen visible regardless of maintenance mode
    if view_var_main.get():
        main_frame.tkraise()


maint_check = tk.Checkbutton(toggle_frame, text="Maintenance", variable=view_var_maint,
                             command=lambda: [view_var_main.set(True), toggle_maintenance_mode(), update_screen_view()],
                             bg="#0b1443", fg="white", selectcolor="#333", font=("Arial", 10))
maint_check.grid(row=0, column=1, padx=10)


#######################################################################################
#######################################################################################
# ---------- LEFT PANEL ---------- #
class LeftPanel(tk.Frame):
    def __init__(self, parent, data):
        self.parent = parent
        super().__init__(parent, bg='#1a1a4d', width=250)
        self.pack_propagate(False)
        self.data = data
        self.create_widgets()
        self.ensure_data_initialized()
        # Connect line change callback:
        self.data.on_line_change.append(self.on_line_changed)
   
    def create_widgets(self):
        #Tabs are now controlled by header
       
        # Railway Crossing Detail
        self.create_crossing_section()
       
        # Switch Details
        self.create_switch_section()
       
        # Light Detail
        self.create_light_section()

        # Initialize with current line data
        self.update_crossing_options()

    def create_crossing_section(self):
        crossing_frame = tk.LabelFrame(self, text="Railway Crossing Detail",
                                      bg='#cccccc', font=('Arial', 9, 'bold'))
        crossing_frame.pack(fill=tk.X, pady=5)
       
        tk.Label(crossing_frame, text="Select Crossing:", bg='#cccccc').pack(pady=2)
        self.crossing_selector = ttk.Combobox(crossing_frame, width=18, state='readonly')
        self.crossing_selector.pack(pady=2)
        self.crossing_selector.bind('<<ComboboxSelected>>', self.update_crossing_display)
       
        tk.Label(crossing_frame, text="Condition:", bg='#cccccc').pack()
        self.crossing_condition = tk.Entry(crossing_frame, width=20, state='readonly')
        self.crossing_condition.pack()
       
        tk.Label(crossing_frame, text="Lights:", bg='#cccccc').pack()
        self.crossing_lights = ttk.Combobox(crossing_frame, width=18,
                                           values=["On", "Off"], state='readonly')
        self.crossing_lights.pack()
        self.crossing_lights.bind('<<ComboboxSelected>>', self.update_crossing_lights)
       
        tk.Label(crossing_frame, text="Bar:", bg='#cccccc').pack()
        self.crossing_bar = ttk.Combobox(crossing_frame, width=18, values=["Closed", "Open"], state='readonly')
        self.crossing_bar.pack()

    def update_crossing_options(self):
        """Update combobox options based on current line"""
        crossings = list(self.data.filtered_track_data.get("crossings", {}).keys())
        self.crossing_selector['values'] = crossings
        if crossings:
            self.crossing_selector.set(crossings[0])
            self.update_crossing_display()
   
    def create_switch_section(self):
        switch_frame = tk.LabelFrame(self, text="Switch Details",
                                    bg='#cccccc', font=('Arial', 9, 'bold'))
        switch_frame.pack(fill=tk.X, pady=5)
       
        tk.Label(switch_frame, text="Select Switch:", bg='#cccccc').pack(pady=2)
        self.switch_selector = ttk.Combobox(switch_frame, width=18, state='readonly')
        self.switch_selector.pack(pady=2)
        self.switch_selector.bind('<<ComboboxSelected>>', self.update_switch_display)
       
        tk.Label(switch_frame, text="Condition:", bg='#cccccc').pack()
        self.switch_condition = tk.Entry(switch_frame, width=20, state='readonly')
        self.switch_condition.pack()
       
        tk.Label(switch_frame, text="Direction:", bg='#cccccc').pack()
        self.switch_direction = ttk.Combobox(switch_frame, width=18,
                                            values=["Blocks 5-11", "Blocks 5-15"])
        self.switch_direction.pack()
        self.switch_direction.bind('<<ComboboxSelected>>', self.update_switch_direction)

        # Initialize with current line data
        self.update_switch_options()

    def ensure_data_initialized(self):
        """Ensure all required data structures exist"""
        if not hasattr(self.data, 'filtered_track_data'):
            self.data.filtered_track_data = {
                "crossings": {},
                "switches": {},
                "lights": {}
            }
        if not hasattr(self.data, 'track_data'):
            self.data.track_data = self.data.filtered_track_data

    def update_switch_options(self):
        """Update combobox options based on current line"""
        switches = list(self.data.filtered_track_data.get("switches", {}).keys())
        self.switch_selector['values'] = switches
        if switches:
            self.switch_selector.set(switches[0])
            self.update_switch_display()
   
    def create_light_section(self):
        light_frame = tk.LabelFrame(self, text="Light Detail",
                                   bg='#cccccc', font=('Arial', 9, 'bold'))
        light_frame.pack(fill=tk.X, pady=5)
       
        tk.Label(light_frame, text="Select Light:", bg='#cccccc').pack(pady=2)
        self.light_selector = ttk.Combobox(light_frame, width=18, state='readonly')
        self.light_selector.pack(pady=2)
        self.light_selector.bind('<<ComboboxSelected>>', self.update_light_display)
       
        tk.Label(light_frame, text="Condition:", bg='#cccccc').pack()
        self.light_condition = tk.Entry(light_frame, width=20, state='readonly')
        self.light_condition.pack()
       
        tk.Label(light_frame, text="Signal:", bg='#cccccc').pack()
        self.light_signal = ttk.Combobox(light_frame, width=18,
                                        values=["Red", "Yellow", "Green", "Super Green" ],
                                        state='readonly')
        self.light_signal.pack()
        self.light_signal.bind('<<ComboboxSelected>>', self.update_light_signal)

        # Initialize with current line data
        self.update_light_options()
   
    def update_light_options(self):
        """Update combobox options based on current line"""
        lights = list(self.data.filtered_track_data.get("lights", {}).keys())
        self.light_selector['values'] = lights
        if lights:
            self.light_selector.set(lights[0])
            self.update_light_display()
           
    def on_line_changed(self):
        """Update all left panel components when line changes"""
        print(f"Left panel: Line changed to {self.data.current_line}")  # Debug
        self.update_crossing_options()
        self.update_switch_options()
        self.update_light_options()
   
    def update_crossing_display(self, event=None):
        selected = self.crossing_selector.get()
        crossings = self.data.filtered_track_data.get("crossings", {})
        if selected in crossings:
            data = crossings[selected]
            self.crossing_condition.config(state='normal')
            self.crossing_condition.delete(0, tk.END)
            self.crossing_condition.insert(0, data["condition"])
            self.crossing_condition.config(state='readonly')
            self.crossing_lights.set(data["lights"])
            self.crossing_bar.set(data["bar"])
   
    def update_crossing_lights(self, event=None):
        selected = self.crossing_selector.get()
        if selected in self.data.track_data["crossings"]:
            old_value = self.data.track_data["crossings"][selected]["lights"]
            new_value = self.crossing_lights.get()
            self.data.track_data["crossings"][selected]["lights"] = self.crossing_lights.get()
            message_logger.log(f"Crossing {selected}: Lights changed from {old_value} to {new_value}", "INFO")

    def update_switch_display(self, event=None):
        selected = self.switch_selector.get()
        switches = self.data.filtered_track_data.get("switches", {})
        if selected in switches:
            data = switches[selected]
            self.switch_condition.config(state='normal')
            self.switch_condition.delete(0, tk.END)
            self.switch_condition.insert(0, data["condition"])
            self.switch_condition.config(state='readonly')
            self.switch_direction.set(data["direction"])
   
    def update_switch_direction(self, event=None):
        selected = self.switch_selector.get()
        if selected in self.data.track_data["switches"]:
            old_value = self.data.track_data["switches"][selected]["direction"]
            new_value = self.switch_direction.get()
            self.data.track_data["switches"][selected]["direction"] = new_value
            message_logger.log(f"Switch {selected}: Direction changed from {old_value} to {new_value}")
   
    def update_light_display(self, event=None):
        selected = self.light_selector.get()
        lights = self.data.filtered_track_data.get("lights", {})
        if selected in lights:
            data = lights[selected]
            self.light_condition.config(state='normal')
            self.light_condition.delete(0, tk.END)
            self.light_condition.insert(0, data["condition"])
            self.light_condition.config(state='readonly')
            self.light_signal.set(data["signal"])
   
    def update_light_signal(self, event=None):
        selected = self.light_selector.get()
        if selected in self.data.track_data["lights"]:
            old_value = self.data.track_data["lights"][selected]["signal"]
            new_value = self.light_signal.get()
            self.data.track_data["lights"][selected]["signal"] = new_value
            message_logger.log(f"Light {selected}: Signal changed from {old_value} to {new_value}")
   
    def update_mode_ui(self):
        # Refresh UI based on maintenance mode
        # pass
        """Update UI elements based on maintenance mode"""
        # enable/diable comoboxes based on mainteneance mode and specific edits
        switch_changes = self.data.is_changeable("switches")
        light_changes = self.data.is_changeable("lights")
        crossing_changes = self.data.is_changeable("crossing")

        # update switch controls
        if switch_changes:
            self.switch_direction.config(state='readonly')
            add_to_message_log("switch controls enabled for maintenance")
        else:
            self.switch_direction.config(state='disabled')
       
        #update light controls
        self.light_signal.config(state='disabled')

        # Update crossing controls (always disabled in this design)
        self.crossing_lights.config(state='disabled')
        self.crossing_bar.config(state='disabled')

        # Visual feedback - change background colors to show editable state
        self.update_visual_feedback()

    def update_visual_feedback(self):
        """Change background colors to indicate editable fields"""
        switch_editable = self.data.is_changeable("switches")
       
        if switch_editable:
            # Make editable fields stand out
            self.switch_direction.config(background='#ffffcc')  # Light yellow for editable
        else:
            self.switch_direction.config(background='white')    # Normal white for read-only
           
        # Keep non-editable fields with normal background
        self.light_signal.config(background='#f0f0f0')          # Grayed out
        self.crossing_lights.config(background='#f0f0f0')
        self.crossing_bar.config(background='#f0f0f0')
   
    def update_switch_direction(self, event=None):
        """Only allow switch direction changes if editable"""
        if not self.data.is_changeable("switches"):
            add_to_message_log("WARNING: Switch changes not allowed in current mode", "WARNING")
            return
           
        selected = self.switch_selector.get()
        if selected in self.data.track_data["switches"]:
            old_value = self.data.track_data["switches"][selected]["direction"]
            new_value = self.switch_direction.get()
            self.data.track_data["switches"][selected]["direction"] = new_value
            add_to_message_log(f"Switch {selected}: Direction changed from {old_value} to {new_value}")
   
    def update_crossing_lights(self, event=None):
        """Prevent crossing light changes"""
        if self.data.maintenance_mode:
            add_to_message_log("WARNING: Crossing light changes not permitted in maintenance mode", "WARNING")
            # Revert to original value
            self.update_crossing_display()
   
    def update_light_signal(self, event=None):
        """Prevent light signal changes"""
        if self.data.maintenance_mode:
            add_to_message_log("WARNING: Light signal changes not permitted in maintenance mode", "WARNING")
            # Revert to original value
            self.update_light_display()

test_data = UITestData()
# Create the left panel with mock data
left_panel = LeftPanel(main_frame, test_data)
left_panel.pack(side="left", fill="y", padx=5, pady=5)

#######################################################################################
#######################################################################################
# ---------- RIGHT PANEL ---------- #
class RightPanel(tk.Frame):
    def __init__(self, parent, data):
        super().__init__(parent, bg='#1a1a4d', width=250)
        self.pack_propagate(False)
        self.data = data
        

        # Connect line change callback
        self.data.on_line_change.append(self.on_line_changed)
        self.data.on_block_change.append(self.on_block_data_changed)

         # Clear any search filters and show all data
        if hasattr(self.data, 'filtered_block_data'):
            self.data.filtered_block_data = self.data.block_data.copy()
        self.create_widgets()
    def on_block_data_changed(self, row_index, col_index, new_value):
        # Update only the affected row in the table if maintenance mode
        if self.data.maintenance_mode:
            self.create_block_table()  # Simple approach: rebuild table
        add_to_message_log(f"[Main UI] Block {self.data.block_data[row_index][2]} updated to {new_value}")
   
    def create_widgets(self):
        # Block selector
        block_frame = tk.Frame(self, bg='#cccccc')
        block_frame.pack(fill=tk.X, pady=5)
        tk.Label(block_frame, text="Block", bg='#cccccc').pack(side=tk.LEFT, padx=5)
       
        # Update block combo based on current line
        self.block_combo = ttk.Combobox(block_frame, width=10, state='readonly')
        self.block_combo.pack(side=tk.LEFT, padx=5)
        self.update_block_options()

        # Suggested section
        self.create_suggested_section()
       
        # Commanded section
        self.create_commanded_section()
       
        # Search and block table
        self.create_block_table_section()

    def update_block_options(self):
        """Update block selector based on current line"""
        blocks = [row[2] for row in self.data.block_data]
        self.block_combo['values'] = blocks
        if blocks:
            self.block_combo.set(blocks[0])
   
    def on_line_changed(self):
        """Refresh right panel when line changes"""
        print(f"Right panel: Line changed to {self.data.current_line}")
        self.update_block_options()
        self.create_block_table()
   
    def create_suggested_section(self):
        suggested_frame = tk.LabelFrame(self, text="Suggested:",
                                       bg='#cccccc', font=('Arial', 10, 'bold'))
        suggested_frame.pack(fill=tk.X, pady=5)
       
        tk.Label(suggested_frame, text="Authority:", bg='#cccccc').pack(anchor='w', padx=5)
        tk.Label(suggested_frame, text="2 blocks", bg='white',
                relief=tk.SUNKEN).pack(fill=tk.X, padx=5, pady=2)
        tk.Label(suggested_frame, text="Speed:", bg='#cccccc').pack(anchor='w', padx=5)
        tk.Label(suggested_frame, text="38 mph", bg='white',
                relief=tk.SUNKEN).pack(fill=tk.X, padx=5, pady=2)
   
    def create_commanded_section(self):
        commanded_frame = tk.LabelFrame(self, text="Commanded:",
                                   bg='#cccccc', font=('Arial', 10, 'bold'))
        commanded_frame.pack(fill=tk.X, pady=5)
   
    # Authority section
        auth_frame = tk.Frame(commanded_frame, bg='#cccccc')
        auth_frame.pack(fill=tk.X, padx=5, pady=2)
        tk.Label(auth_frame, text="Authority:", bg='#cccccc').pack(side=tk.LEFT)
   
        self.auth_entry = tk.Entry(auth_frame, width=10)
        self.auth_entry.insert(0, "2 blocks")  # Default value
        self.auth_entry.pack(side=tk.LEFT, padx=2)
   
        auth_button = tk.Button(auth_frame, text="Send", width=5, command=self.update_authority)
        auth_button.pack(side=tk.LEFT)
   
    # Speed section
        speed_frame = tk.Frame(commanded_frame, bg='#cccccc')
        speed_frame.pack(fill=tk.X, padx=5, pady=2)
        tk.Label(speed_frame, text="Speed:", bg='#cccccc').pack(side=tk.LEFT)
   
        self.speed_entry = tk.Entry(speed_frame, width=10)
        self.speed_entry.insert(0, "38 mph")  # Default value
        self.speed_entry.pack(side=tk.LEFT, padx=2)
   
        speed_button = tk.Button(speed_frame, text="Send", width=5, command=self.update_speed)
        speed_button.pack(side=tk.LEFT)

    def update_authority(self):
        """Update commanded authority and log the change"""
        new_authority = self.auth_entry.get()
        add_to_message_log(f"Commanded Authority updated to: {new_authority}")
        # Here you would also update the backend data structure
        # commanded_authority.append(new_authority)

    def update_speed(self):
        """Update commanded speed and log the change"""
        new_speed = self.speed_entry.get()
        add_to_message_log(f"Commanded Speed updated to: {new_speed}")
    # Here you would also update the backend data structure
    # commanded_speed.append(new_speed)
    #######################################################################################################################
    ######################################################################################################################
    def update_suggested_speed(self, speed_value):
    # """Update the suggested speed display with formatted value"""
        try:
            if speed_value is not None:
                formatted_speed = f"{speed_value:.3f} mph"
                self.suggested_speed_label.config(text=formatted_speed)
                add_to_message_log(f"Suggested Speed updated to: {formatted_speed}")
            else:
                add_to_message_log("ERROR: Invalid speed value received", "ERROR")
        except Exception as e:
            add_to_message_log(f"ERROR updating speed display: {e}", "ERROR")

    def update_suggested_authority(self, authority_value):
        """Update the suggested authority display"""
        try:
            if authority_value is not None:
                formatted_authority = f"{authority_value} blocks"
                self.suggested_authority_label.config(text=formatted_authority)
                add_to_message_log(f"Suggested Authority updated to: {formatted_authority}")
            else:
                add_to_message_log("ERROR: Invalid authority value received", "ERROR")
        except Exception as e:
            add_to_message_log(f"ERROR updating authority display: {e}", "ERROR")
   ############################################################################################################################
   ##############################################################################################################################
    def create_block_table_section(self):
    # Search
        search_frame = tk.Frame(self, bg='#1a1a4d')
        search_frame.pack(fill=tk.X, pady=5)
        self.block_search_var = tk.StringVar()
        self.block_search_var.trace('w', self.filter_block_table)
        block_search = tk.Entry(search_frame, textvariable=self.block_search_var, width=20)
        block_search.pack(side=tk.LEFT, padx=5)
        tk.Label(search_frame, text="Search", bg='#1a1a4d', fg='white', font=('Arial', 9)).pack(side=tk.LEFT)
   
    # Create scrollable table with fixed height
        table_container = tk.Frame(self, bg='white', relief=tk.SUNKEN, borderwidth=2, height=300)
        table_container.pack(fill=tk.BOTH, expand=True, pady=5)
        # table_container.pack_propagate(False)  # Prevent container from shrinking
   
    # Create a frame for canvas and scrollbar
        scroll_frame = tk.Frame(table_container, bg='white')
        scroll_frame.pack(fill=tk.BOTH, expand=True)
   
    # Canvas and scrollbar
        canvas = tk.Canvas(scroll_frame, bg='white', highlightthickness=0)
        scrollbar = tk.Scrollbar(scroll_frame, orient="vertical", command=canvas.yview)
        self.block_table_frame = tk.Frame(canvas, bg='white')
   
    # Configure scrolling
        self.block_table_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
   
        canvas.create_window((0, 0), window=self.block_table_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
   
    # Pack canvas and scrollbar
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
   
    # Add mousewheel scrolling
    def _on_mousewheel(event):
        canvas.yview_scroll(int(-1*(event.delta/120)), "units")
    
        canvas.bind("<MouseWheel>", _on_mousewheel)
        self.block_table_frame.bind("<MouseWheel>", _on_mousewheel)

        # Force the table to be created immediately with ALL data
        self.block_search_var.set("")  # Clear any search text
        self.data.filter_block_data("")  # Show all data

        self.create_block_table()
   
    def create_block_table(self):
        print(f"DEBUG: Creating block table in frame: {self.block_table_frame}")
        print(f"DEBUG: Frame width: {self.block_table_frame.winfo_width()}, height: {self.block_table_frame.winfo_height()}")

    # Clear existing widgets
        for widget in self.block_table_frame.winfo_children():
            widget.destroy()
     # Get the filtered data
        block_data = self.data.get_block_table_data()

        # print(f"DEBUG: Block data received: {len(block_data)} rows")
        # if block_data:
            # print(f"DEBUG: First row: {block_data[0]}")
            # print(f"DEBUG: Row structure: {[len(row) for row in block_data]}")

    # # Check if we have data
    #     if not block_data:
    #         tk.Label(self.block_table_frame, text="No block data available", 
    #                 bg='white', fg='red').pack(pady=20)
    #         print("WARNING: No block data, using sample data")
    #         block_data = [
    #         ["No", "Green", "74", "M", ""],
    #         ["No", "Green", "75", "M", ""],
    #         ["No", "Green", "76", "M", ""],
    #         ["No", "Green", "77", "N", "STATION; MT LEBANON"],
    #         ["No", "Green", "108", "T", "RAILWAY CROSSING"]
    #         ]
    #     return
    # Headers - 4 columns
        headers_frame = tk.Frame(self.block_table_frame, bg='#cccccc')
        headers_frame.pack(fill=tk.X)
   
    # define consistent widths for all columns
        col_widths = {
            'occupied': 8,
            'line': 6,
            'block': 6,
            'section': 8,
            'infrastructure': 15
        }

        tk.Label(headers_frame, text="Occupied", bg='#cccccc',
            font=('Arial', 8, 'bold'), width=col_widths['occupied']).pack(side=tk.LEFT, padx=1)
        tk.Label(headers_frame, text="Line", bg='#cccccc',
            font=('Arial', 8, 'bold'), width=col_widths['line']).pack(side=tk.LEFT, padx=2)
        tk.Label(headers_frame, text="Block", bg='#cccccc',
            font=('Arial', 8, 'bold'), width=col_widths['block']).pack(side=tk.LEFT, padx=2)
        tk.Label(headers_frame, text="Section", bg='#cccccc',
            font=('Arial', 8, 'bold'), width=col_widths['section']).pack(side=tk.LEFT, padx=2)
   
    # Data rows
        self.block_combos = []  # Store references to comboboxes

        # Use filtered data for display
        display_data = self.data.filtered_block_data if hasattr(self.data, 'filtered_block_data') else self.data.block_data

        for row_index, row in enumerate(display_data):
            # print(f"DEBUG: Processing row {row_index}: {row}")
            row_frame = tk.Frame(self.block_table_frame, bg='white')
            row_frame.pack(fill='x', pady=1)
        try:
            while len(row) < 5:
                row.append("")  # Add empty strings for missing columns

            if self.data.maintenance_mode:
            # Editable in maintenance mode - OCCUPIED COMBO
                occ_combo = ttk.Combobox(row_frame, values=["Yes", "No"], width=col_widths['occupied']-2)
                occ_combo.set(row[0])
                occ_combo.pack(side=tk.LEFT, padx=1)

            # Bind the change event to update data model
                occ_combo.bind('<<ComboboxSelected>>',
                    lambda event, idx=row_index, combo=occ_combo:
                    self.on_block_data_change(idx, 0, combo.get()))
           
            # LINE - READ ONLY (track color should not change)
                bg_color = '#66cc66' if row[1] == "Green" else '#ff6666' if row[1] == "Red" else '#6666ff'
                tk.Label(row_frame, text=row[1], bg=bg_color, width=col_widths['line'],
                    borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
           
            # Block number (read-only)
                tk.Label(row_frame, text=row[2], bg='white', width=col_widths['block'],
                    borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
            
            # Section letter (read-only)
                tk.Label(row_frame, text=row[3], bg='white', width=col_widths['section'],
                    borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
             
            #  Infrastructure (read-only) 
                tk.Label(row_frame, text=str(row[4]), bg='white', width=col_widths['infrastructure'],
                    borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
            # Store combos for potential access
                self.block_combos.append(occ_combo)
           
            else:
            # Read-only in normal mode - all labels
            # print(f"DEBUG: Creating normal mode labels for block {row[2]}")
                tk.Label(row_frame, text=row[0], bg='white', width=col_widths['occupied'],
                    borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
            
                bg_color = '#66cc66' if row[1] == "Green" else '#ff6666' if row[1] == "Red" else '#6666ff'
                tk.Label(row_frame, text=row[1], bg=bg_color, width=col_widths['line'],
                    borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
            
                tk.Label(row_frame, text=row[2], bg='white', width=col_widths['block'],
                    borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
            
                tk.Label(row_frame, text=row[3], bg='white', width=col_widths['section'],
                    borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)

                tk.Label(row_frame, text=str(row[4]), bg='white', width=col_widths['infrastructure'],
                borderwidth=1, relief=tk.GROOVE).pack(side=tk.LEFT, padx=1)
        except Exception as e:
            print(f"Error creating row {row_index}: {e} - Row data: {row}")
    
        if i < 3:  # Debug first 3 rows
            print(f"DEBUG: Created row {i}: {row}")
    
        print(f"DEBUG: Finished creating {len(block_data)} rows")
    # Force update
        self.block_table_frame.update()            
    # print("DEBUG: Finished creating block table")

    def on_block_data_change(self, row_index, col_index, new_value):
        """Callback when any block data is changed in maintenance mode"""
        print(f"Block data changed: row {row_index}, col {col_index}, value '{new_value}'")
        self.data.update_block_data(row_index, col_index, new_value)
       
    def filter_block_table(self, *args):
        search_term = self.block_search_var.get().lower()
        self.data.filter_block_data(search_term)
        self.create_block_table()
   
    def update_mode_ui(self):
        """Refresh block table when mode changes"""
        self.create_block_table()
#############################################################################################################
################################################################################################################
    class CTCSpeedHandler:
        """Handles CTC suggested speed messages with clear, modular methods"""
    
    # @staticmethod
    def extract_speed_from_string(speed_string):
        """Extract speed value from string format"""
        try:
            # Handle "float: 45.5" format
            if "float:" in speed_string:
                import re
                float_match = re.search(r'float:\s*([0-9]*\.?[0-9]+)', speed_string)
                if float_match:
                    return float(float_match.group(1))
            
            # Handle direct number string
            return float(speed_string)
            
        except (ValueError, TypeError):
            return None
    
    # @staticmethod
    def extract_speed_from_dict(speed_dict):
        """Extract speed value from dictionary format"""
        try:
            # Try different possible dictionary keys
            if 'Suggested_speed' in speed_dict:
                speed_value = speed_dict['Suggested_speed']
                if isinstance(speed_value, str):
                    return CTCSpeedHandler.extract_speed_from_string(speed_value)
                else:
                    return float(speed_value)
                    
            elif 'value' in speed_dict:
                return float(speed_dict['value'])
                
            elif 'speed' in speed_dict:
                return float(speed_dict['speed'])
                
        except (ValueError, TypeError, KeyError):
            return None
    
    # @staticmethod
    def format_speed_value(speed):
        """Format speed to 3 decimal places"""
        if speed is not None:
            return round(float(speed), 3)
        return None
    
    # @staticmethod
    def handle_ctc_speed_message(speed_data):
        """
        Main method to handle CTC speed messages
        Returns formatted speed value or None if invalid
        """
        print(f"DEBUG: Processing CTC speed data: {speed_data}")
        
        extracted_speed = None
        
        # Handle different input types
        if isinstance(speed_data, str):
            extracted_speed = CTCSpeedHandler.extract_speed_from_string(speed_data)
            
        elif isinstance(speed_data, dict):
            extracted_speed = CTCSpeedHandler.extract_speed_from_dict(speed_data)
            
        elif isinstance(speed_data, (int, float)):
            extracted_speed = float(speed_data)
        
        # Format the speed value
        formatted_speed = CTCSpeedHandler.format_speed_value(extracted_speed)
        
        # Log the result
        if formatted_speed is not None:
            add_to_message_log(f"CTC Suggested Speed Processed: {formatted_speed:.3f} mph")
        else:
            add_to_message_log(f"ERROR: Could not process CTC speed data: {speed_data}", "ERROR")
        
        return formatted_speed
#############################################################################################################
################################################################################################################
# Create the right panel with mock data
right_panel = RightPanel(main_frame, test_data)
right_panel.pack(side="right", fill="y", padx=5, pady=5)

# ---------- MAINTENANCE SCREEN (simple placeholder) ---------- #
maint_label = tk.Label(maintenance_frame, text="Maintenance Mode Active", bg="#0b1443", fg="white", font=("Arial", 24))
maint_label.place(relx=0.3, rely=0.4)

# Raise main screen by default
main_frame.tkraise()

root.mainloop()